#!/usr/bin/env bash

# Usage:
#   bash <(curl -sL https://raw.githubusercontent.com/VisionSystemsInc/vsi_common/master/linux/new_just)

set -eu

# Redirect stderr to stdout, and stdout to 3; now the only way to write to
# stdout or stderr is to write to 3
exec 3>&1 # Copy stdout to 3
exec 1>&2 # Copy stderr to 1

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
if [ -f "${VSI_COMMON_DIR}/linux/ask_question" ]; then
  source "${VSI_COMMON_DIR}/linux/ask_question"
else
  function ask_question()
  {
    if [ "${!2-}" != "1" ]; then
      read -r -p "${1} (${3}) " "${2}"
    fi

    if [ -z "${!2-unset}" ] || [ "${!2::1}" = "1" ] ||
       [ "${!2::1}" = "y" ] || [ "${!2::1}" = "Y" ]; then
      eval $2=1
    else
      eval $2=0
    fi
  }
fi

#****F* just/new_just
# NAME
#   new_just - Create a new just project
# DESCRIPTION
#   There are many moving pieces to set up a working just project and use
#   all the features. Just getting started is hard, without knowing where to
#   start. This script will create all the files necessary to have a new
#   docker-compose based just project up and running.
# USAGE
#   By default, new_just will prompt the user for questions on the initial
#   setup parameters. Default values are supplied for all questions, and enter
#   can be pressed to accept all the defaults. All of the questions can be set
#   using environment variables, making them scriptable.
#
#   After new_just is called, a few git commands need to be called. This is not
#   done for you, in case it will break your existing repository. These
#   commands are printed out on stdout, while everything else is printed on
#   stderr, making them scriptable.
#
#   If any of the files written to exist, they are not overwritten, and a warning
#   message is printed out.
# SEE ALSO
#   new_just/PROJECT_DIR, new_just/PROJECT_NAME, new_just/PROJECT_PREFIX
#   new_just/REPO_NAME, new_just/JUSTFILE, new_just/WRAPFILE, new_just/SETUPFILE
#   new_just/VSI_DIR
# AUTHOR
#   Andy Neff
#***

echo "Setting up a new project to use J.U.S.T."
echo

#****d* new_just/PROJECT_DIR
# NAME
#   PROJECT_DIR - The main project directory
# DESCRIPTION
#   The project directory is typically the root directory of the main git
#   repository. This is where all the just files will be stored by default.
#
#   The value can be customized when prompted by new_just. The default value
#   is the current working directory. The question can be skipped by setting
#   the environment variable PROJECT_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_DIR="$(read -r -p "Project directory (${PWD}) " x; echo "$x")"}
if [ "${PROJECT_DIR}" == "" ]; then
  PROJECT_DIR="${PWD}"
else
  mkdir -p "${PROJECT_DIR}"
  PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
fi

#****d* new_just/PROJECT_NAME
# NAME
#   PROJECT_NAME - Name of the just project being created
# DESCRIPTION
#   The PROJECT_NAME is used to set the project environment file name used by
#   source_environment_files. Specifically: ${PROJECT_DIR}/${PROJECT_NAME}.env
#   PROJECT_NAME is also used for for determining other default values.
#
#   The value can be customized when prompted by new_just. The default value
#   is basename of the PROJECT_DIR. The question can be skipped by setting the
#   environment variable PROJECT_NAME to the desired value.
# SEE ALSO
#   just/source_environment_files
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_NAME="$(read -r -p "Project name ($(basename "${PROJECT_DIR}")) " x; echo "$x")"}
if [ "${PROJECT_NAME}" == "" ]; then
  PROJECT_NAME="$(basename "${PROJECT_DIR}")"
fi

#****d* new_just/PROJECT_PREFIX
# NAME
#   PROJECT_PREFIX - The prefix of environment variables for this project
# DESCRIPTION
#   Used to set the value of JUST_PROJECT_PREFIX. Must contain only valid bash
#   variable-name characters: [A-Z0-9_]+
#
#   Does not need the trailing _ included, this will always be added when it is
#   used.
#
#   The value can be customized when prompted by new_just. The default value is
#   uppercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable PROJECT_PREFIX to the desired value.
# SEE ALSO
#   just/JUST_PROJECT_PREFIX
# AUTHOR
#   Andy Neff
#***
default=$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
: ${PROJECT_PREFIX="$(read -r -p "Project variable prefix (${default}) " x; echo $x)"}
if [ "${PROJECT_PREFIX}" == "" ]; then
  PROJECT_PREFIX=${default}
else
  PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
fi

#****d* new_just/JUSTFILE
# NAME
#   JUSTFILE - Name of the justfile used
# DESCRIPTION
#   The default just file in just is "Justfile". If this is changed, the only
#   way to inform just of this is by setting it in the SETUPFILE. This will be
#   added to the SETUPFILE by new_just if anything other than the default is
#   used.
#
#   The value can be customized when prompted by new_just. The default value
#   is Justfile. The question can be skipped by setting the environment variable
#   JUSTFILE to the desired value.
# SEE ALSO
#   new_just/SETUPFILE, just/Justfile
# AUTHOR
#   Andy Neff
#***
: ${JUSTFILE="$(read -r -p "Just file name (Justfile) " x; echo "$x")"}
if [ "${JUSTFILE}" == "" ]; then
  JUSTFILE="Justfile"
else
  JUSTFILE="$(basename ${JUSTFILE})"
fi

#****d* new_just/SETUPFILE
# NAME
#   SETUPFILE - Name of the setup file sourced to setup just environment
# DESCRIPTION
#   The setup file is used to make the minimal necessary changes to the
#   environment so that just works. This includes adding paths and setting a
#   few environment variables. This is meant to be as unobtrusive as possible.
#
#   This file needs to be sourced every time a new terminal session is opened.
#   The only time the setup script is not needed is when calling the WRAPFILE.
#
#   The value can be customized when prompted by new_just. The default value is
#   setup.env. The question can be skipped by setting the environment variable
#   SETUPFILE to the desired value.
# SEE ALSO
#   new_just/WRAPFILE
# AUTHOR
#   Andy Neff
#***
: ${SETUPFILE="$(read -r -p "Environment setup script file name (setup.env) " x; echo "$x")"}
if [ "${SETUPFILE}" == "" ]; then
  SETUPFILE="setup.env"
else
  SETUPFILE="$(basename ${SETUPFILE})"
fi

#****d* new_just/WRAPFILE
# NAME
#   WRAPFILE - The wrap filename that runs any command in the just environment
# DESCRIPTION
#   The wrap file can be used to run any command in the full just environment or
#   to enter a bash session in this environment.
#
#   The value can be customized when prompted by new_just. The default value is
#   wrap. The question can be skipped by setting the environment variable
#   WRAPFILE to the desired value.
# SEE ALSO
#   just/Just_wrap
# AUTHOR
#   Andy Neff
#***
: ${WRAPFILE="$(read -r -p "Wrap script file name (wrap) " x; echo "$x")"}
if [ "${WRAPFILE}" == "" ]; then
  WRAPFILE="wrap"
else
  WRAPFILE="$(basename ${WRAPFILE})"
fi

#****d* new_just/VSI_DIR
# NAME
#   VSI_DIR - Location of the vsi_common submodule
# DESCRIPTION
#   The vsi_common repository is necessary for virtually all of the just
#   capabilities. The correct way to deal with this is to add vsi_common as a
#   submodule for your main project. This tells just were this submodule is
#   located.
#
#   The value can be customized when prompted by new_just. The default value is
#   external/vsi_common. The question can be skipped by setting the environment
#   variable VSI_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${VSI_DIR="$(read -r -p "VSI common module path (./external/vsi_common) " x; echo "$x")"}
if [ "${VSI_DIR}" == "" ]; then
  VSI_DIR="${PROJECT_DIR}/external/vsi_common"
else
  VSI_DIR="$(cd "${PROJECT_DIR}";
             mkdir -p "${VSI_DIR}";
             cd "${VSI_DIR}";
             pwd)"
fi


## Docker Stuff

#****d* new_just/USE_DOCKER
# NAME
#   USE_DOCKER - Flag to turn on all the docker features
# AUTHOR
#   Andy Neff
#***
ask_question "Use docker?" USE_DOCKER y

#****d* new_just/USE_PIPENV
# NAME
#   USE_PIPENV - Flag to turn on setting up pipenv
# AUTHOR
#   Andy Neff
#***
ask_question "Use pipenv?" USE_PIPENV y

if [ "${USE_DOCKER}" = "1" ]; then
  #****d* new_just/APP_NAME
  # NAME
  #   APP_NAME - The name of the test app generated
  # DESCRIPTION
  #   Used for the name of the first service populated for you
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_.-]+||g')
  : ${APP_NAME="$(read -r -p "Name of the example docker-compose app (${default}) " x; echo $x)"}
  if [ "${APP_NAME}" == "" ]; then
    APP_NAME=${default}
  else
    APP_NAME=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_.-]+||g')
  fi

  APP_NAME_UPPER=$(echo "${APP_NAME}" | tr '[a-z]' '[A-Z]')

  #****d* new_just/REPO_NAME
  # NAME
  #   REPO_NAME - Name of docker repository where images are stored
  # DESCRIPTION
  #   When docker images are built, they need to be named, or else the only way to
  #   access them is inconveniently though sha256 checksums.
  #
  #   The REPO_NAME should be an untagged docker repository name. Tag names will
  #   be added for each service. Docker image names must match the regex
  #   [a-zA-Z0-9][a-zA-Z0-9_.-]* or else docker will error
  #
  #   The value can be customized when prompted by new_just. The default value is
  #   lowercase of the PROJECT_NAME. The question can be skipped by setting the
  #   environment variable REPO_NAME to the desired value.
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
  : ${REPO_NAME="$(read -r -p "Docker Repo for images (${default}) " x; echo $x)"}
  if [ "${REPO_NAME}" == "" ]; then
    REPO_NAME=${default}
  else
    REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
  fi
fi

echo "Summary"
echo "======="
printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
printf "%-40s | %-40s\n" "Wrap script" "${WRAPFILE}"

printf "%-40s | %-40s\n" "Use docker" "${USE_DOCKER}"
printf "%-40s | %-40s\n" "Use pipenv" "${USE_PIPENV}"
if [ "${USE_DOCKER}" = "1" ]; then

  printf "%-40s | %-40s\n" "App Name" "${APP_NAME}"
  printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
  printf "%-40s | %-40s\n" "VSI Common Directory" "${VSI_DIR}"
fi
echo
# Ask y/n question
ask_question "Continue?" CONTINUE y

if [ "${CONTINUE}" != "1" ]; then
  exit 1
fi

# Setup done, start making the new environment

# RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${VSI_DIR}', '${PROJECT_DIR}'))")"
RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${VSI_DIR}','${PROJECT_DIR}');")"

# Make project dir
mkdir -p "${PROJECT_DIR}"
cd "${PROJECT_DIR}"

# Make wrap script
if [ ! -e "${WRAPFILE}" ]; then
  echo '#!/usr/bin/env bash' > "${WRAPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${WRAPFILE}"
  fi
  echo ': "$(dirname "${BASH_SOURCE[0]}")"
. "${VSI_COMMON_DIR:-"${_}"/'"${RELATIVE_PATH}"'}/linux/Just_wrap" "${_}"/'"${PROJECT_NAME}"'.env ${@+"${@}"}' >> "${WRAPFILE}"

else
  echo "${WRAPFILE} exists, skipping..."
fi

# Make setup script
if [ ! -e "${SETUPFILE}" ]; then
  echo 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
unset JUST_VERSION
source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${RELATIVE_PATH}"'/env.bsh"' > "${SETUPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${SETUPFILE}"
  fi
else
  echo "${SETUPFILE} exists, skipping..."
fi


# Make the project settings file

if [ ! -e "${PROJECT_NAME}.env" ]; then
  echo 'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
'"${PROJECT_PREFIX}"'_CWD="${CWD-"$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"}"
'  > "${PROJECT_NAME}.env"

  if [ "${USE_DOCKER}" = "1" ]; then
    echo ': ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

: ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
: ${'"${PROJECT_PREFIX}"'_USERNAME=$(id -u -n)}
: ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
: ${'"${PROJECT_PREFIX}"'_GIDS=$(id -G)}
: ${'"${PROJECT_PREFIX}"'_GROUP_NAMES=$(group_names)}

# This directory is setup using docker-compose file. It always exists
: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR="${'"${PROJECT_PREFIX}"'_CWD}"}
: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER="/src"}

# This directory is setup using '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES below
# This is a better mechanism, in case the directory doesn'"'"'t exist. The directory
# will be created and owned properly
: ${'"${PROJECT_PREFIX}"'_DATA_DIR="${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/new-data"}
: ${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER="/data"}

if [ "${VSI_OS}" = "linux" ]; then
  '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
      ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
fi

'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES=(
    "${'"${PROJECT_PREFIX}"'_DATA_DIR}:${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER}"
    ${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES[@]}"})

###############################################################################
### Non-'"${PROJECT_PREFIX}"' Setting ###
###############################################################################

# Put variables that do not begin with '"${PROJECT_PREFIX}"' here.

# Use this to add the username to the docker-compose project name. This is
# important when multiple users are using this docker-compose project on a
# single host. This way all of the docker resources are prefixed with a unique
# name and do not collide
source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
: ${COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${'"${PROJECT_PREFIX}"'_CWD}" "${'"${PROJECT_PREFIX}"'_USERNAME}")}

' >> "${PROJECT_NAME}.env"
  fi

else
  echo "${PROJECT_NAME}.env exists, skipping..."
fi

# Make default README
if [ ! -e "README.md" ]; then
  echo '## Getting started

```
. setup.env' > README.md
if [ "${USE_DOCKER}" = "1" ]; then
  echo "just setup
just run ${APP_NAME}" >> README.md
else
  echo "just compile
just run" >> README.md
fi
  echo '```

## Just usage:

```
source "'"${SETUPFILE}"'"
just help
```
' >> README.md
else
  echo "README.md exists, skipping..."
fi

# Make Just file
if [ ! -e "${JUSTFILE}" ]; then
  if [ "${USE_DOCKER}" = "1" ]; then
    echo '#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
  set -euE
fi

source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${WRAPFILE}"'"
cd "${'"${PROJECT_PREFIX}"'_CWD}"

# Plugins
source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
source "${VSI_COMMON_DIR}/linux/just_docker_functions.bsh"
source "${VSI_COMMON_DIR}/linux/just_git_functions.bsh"

# Main function
function caseify()
{
  local just_arg=$1
  shift 1
  case ${just_arg} in
    build) # Build Docker image
      if [ "$#" -gt "0" ]; then
        Docker-compose "${just_arg}" ${@+"${@}"}
        extra_args+=$#
      else
        (justify build_recipes)
        Docker-compose build
      fi
      ;;
    run_'"${APP_NAME}"') # Run '"${APP_NAME}"' 1
      Just-docker-compose run '"${APP_NAME}"' ${@+"${@}"}
      extra_args+=$#
      ;;

    setup) # Run any special command to set up the environment for the first \
      # time after checking out the repo. Usually population of volumes/databases \
      # go here.
      (justify _sync)
      ;;
    sync) # Synchronize the many aspects of the project when new code changes \
          # are applied e.g. after "git checkout"
      (justify _sync)
      # Add any extra steps run when syncing when not installing
      ;;
    _sync)
      Docker-compose down
      (justify git_submodule-update) # For those users who don'"'"'t remember!
      (justify build)' > "${JUSTFILE}"
      if [ "${USE_PIPENV}" = "1" ]; then
        echo '      (justify clean venv)' >> "${JUSTFILE}"
      fi
      echo '      ;;
    clean_all) # Delete all local volumes
      ask_question "Are you sure? This will packages not in Pipfile!" n
      (justify clean venv)
      ;;
    clean_venv) # Delete the virtual environment volume. The next container \
                # to use this volume will automatically copy the contents from \
                # the image.
      if docker volume inspect "${COMPOSE_PROJECT_NAME}_venv" &> /dev/null; then
        Docker volume rm "${COMPOSE_PROJECT_NAME}_venv"
      else
        echo "${COMPOSE_PROJECT_NAME}_venv already removed"
      fi
      ;;
    *)
      defaultify "${just_arg}" ${@+"${@}"}
      ;;
  esac
}

if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi
' >> "${JUSTFILE}"
  else
    echo '#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
  set -euE
fi

source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${WRAPFILE}"'"
cd "${'"${PROJECT_PREFIX}"'_CWD}"

function caseify()
{
  local just_arg=$1
  shift 1
  case ${just_arg} in
    compile) # Build program
      g++ hi.cpp -o hi
      ;;
    run) # Run program
      ./hi ${@+"${@}"}
      extra_args+=$#
      ;;
    *)
      defaultify "${just_arg}" ${@+"${@}"}
      ;;
  esac
}

if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi
' > "${JUSTFILE}"
  fi
else
  echo "${JUSTFILE} exists, skipping..."
fi

if [ "${USE_PIPENV}" = "1" ]; then
  if [ ! -e "Pipfile" ]; then
    touch Pipfile
  fi
  if [ ! -e "Pipfile.lock" ]; then
    touch Pipfile.lock
  fi
fi

if [ "${USE_DOCKER}" = "1" ]; then
  mkdir -p docker

  # Make default dockerfiles
  if [ ! -e "docker/${APP_NAME}.Dockerfile" ]; then
    echo 'FROM vsiri/recipe:gosu as gosu
FROM vsiri/recipe:tini as tini' > docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      echo 'FROM vsiri/recipe:pipenv as pipenv' >> docker/${APP_NAME}.Dockerfile
    fi

    echo '
FROM debian:stretch

SHELL ["/usr/bin/env", "bash", "-euxvc"]

# Example of installing packages
RUN build_deps="wget ca-certificates"; \
    apt-get update; \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${build_deps} python3; \
    wget -q https://www.vsi-ri.com/bin/deviceQuery; \
    DEBIAN_FRONTEND=noninteractive apt-get purge -y --autoremove ${build_deps}; \
    rm -rf /var/lib/apt/lists/*

COPY --from=tini /usr/local/bin/tini /usr/local/bin/tini

COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu
# Allow non-privileged to run gosu (remove this to take root away from user)
RUN chmod u+s /usr/local/bin/gosu
' >> docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      echo 'COPY --from=pipenv /tmp/pipenv /tmp/pipenv
RUN python3 /tmp/pipenv/get-pipenv; rm -r /tmp/pipenv
ENV WORKON_HOME=/venv \
    PIPENV_PIPFILE=/src/Pipfile \
    # Needed for pipenv shell \
    PYENV_SHELL=/bin/bash \
    LC_ALL=C.UTF-8 \
    LANG=C.UTF-8
ADD Pipfile Pipfile.lock /src/
# Break apart into multiple steps if it gets too big. Manually pick big packages
# And install them separate RUN commands
RUN if [ ! -s Pipfile.lock ]; then \
      pipenv lock; \
    fi; \
    pipenv install; \
    # Cleanup and make way for the real /src that will be mounted at runtime
    rm -r /src

# Packages can be added to your project using either:
# - "just run '"${APP_NAME}"'" and running "pipenv install {package}" e.g. "pipenv install scipy"
# - Editing the Pipfile and adding lines to the [packages] section, e.g. "scipy = '"'"'*'"'"'"

# Here'"'"'s a more complicated example, say GDAL is in your Pipfile
# Hint: To get GDAL in the Pipfile, add '"'"'gdal = "==2.1.0"'"'"'
#       to the [packages] section of the Pipfile.
#       The version of the pypi package should match (as close as possible)
#       the GDAL binary version installed; then uncomment these lines:
# RUN build_deps="libgdal-dev python3-dev g++"; \
#     apt-get update; \
#     # Install build dependencies and runtime dependencies
#     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
#       gdal-bin ${build_deps}; \
#     cd /src; \
#     # Gdal specific hacks
#     export CPLUS_INCLUDE_PATH=/usr/include/gdal; \
#     export C_INCLUDE_PATH=/usr/include/gdal; \
#     # Build up venv
#     # First you must install the version of numpy specified by the Pipfile.lock
#     if [ ! -s Pipfile.lock ]; then \
#       pipenv lock; \
#     fi; \
#     pipenv install; \
#     # Cleanup
#     rm -rv /src/*; \
#     # Remove build dependencies, you are done with them
#     apt-get purge -y --auto-remove ${build_deps}; \
#     rm -r /var/lib/apt/lists/*

# Another Example
# RUN if [ ! -s Pipfile.lock ]; then \
#       pipenv lock; \
#     fi; \
#     # Some libraries like scikit-garden==0.1.3 need numpy setup tools installed
#     # before installing the to compile with.
#     pipenv install --skip-lock "numpy$(python3 -c "import json; print(json.load(open('"'"'Pipfile.lock'"'"', '"'"'r'"'"'))['"'"'default'"'"']['"'"'numpy'"'"']['"'"'version'"'"'])" 2>/dev/null)"; \
#     # Install everything else now that numpy is available.
#     pipenv sync

' >> docker/${APP_NAME}.Dockerfile
    fi

    echo '
ADD '"${RELATIVE_PATH}"' /vsi
ADD docker/'"${APP_NAME}"'_entrypoint.bsh /

ENTRYPOINT ["/usr/local/bin/tini", "/usr/bin/env", "bash", "/'"${APP_NAME}"'_entrypoint.bsh"]
# Does not require execute permissions, unlike:
# ENTRYPOINT ["/usr/local/bin/tini", "/'"${APP_NAME}"'_entrypoint.bsh"]

CMD ["'"${APP_NAME}"'"]' >> docker/${APP_NAME}.Dockerfile
  else
    echo "docker/${APP_NAME}.Dockerfile exists, skipping..."
  fi

  if [ ! -e "docker/${APP_NAME}_entrypoint.bsh" ]; then
    echo '#!/usr/bin/env bash

set -eu

source "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/wrap"

if [ "${ALREADY_RUN_ONCE+set}" != "set" ]; then
  # create the user and associated groups and handle nfs symlinks' > "docker/${APP_NAME}_entrypoint.bsh"

    if [ "${USE_PIPENV}" = "1" ]; then
      echo '  source "${VSI_COMMON_DIR}/linux/elements.bsh"
  join_a venvs /venv/*
  JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS="${venvs}" \' >> "docker/${APP_NAME}_entrypoint.bsh"
    fi

    echo '  /usr/bin/env bash /vsi/linux/docker_entrypoint.bsh

  # Rerun entrypoint as user now, (skipping the root part via ALREADY_RUN_ONCE)
  ALREADY_RUN_ONCE=1 exec gosu ${DOCKER_USERNAME} /usr/bin/env bash $0 ${@+"${@}"}
fi

function sudo()
{
  gosu root ${@+"${@}"}
}
export -f sudo

source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
# Remove duplicate '"${PROJECT_PREFIX}"'_*_DOCKER variables
filter_docker_variables

' >> "docker/${APP_NAME}_entrypoint.bsh"

    if [ "${USE_PIPENV}" = "1" ]; then
      echo 'if [ "$1" == "'"${APP_NAME}"'" ]; then
  if [ ! -s "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/Pipfile.lock" ]; then
    pipenv lock
  fi
  pipenv shell
elif [ "$1" == "nopipenv" ]; then
  shift 1
  exec "${@}"
else
  if [ ! -s "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/Pipfile.lock" ]; then
    pipenv lock
  fi
  exec pipenv run "${@}"
fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    else
      echo 'if [ "$1" == "'"${APP_NAME}"'" ]; then
  echo "Run '"${APP_NAME}"' here: ${@+${@}}"
else
  exec "${@}"
fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    fi
  else
    echo "docker/${APP_NAME}_entrypoint.bsh exists, skipping..."
  fi


  # Make default docker-compose.yml
  if [ ! -e "docker-compose.yml" ]; then
    echo 'version: "3.2"

services:
  '"${APP_NAME}"': &'"${APP_NAME}"'_anchor
    build:
      context: .
      dockerfile: docker/'"${APP_NAME}"'.Dockerfile
    # prevent different users from clobbering each others images
    image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME}
    environment:
      # Variables for docker_entrypoint.bsh
      - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
      - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
      - DOCKER_GROUP_NAMES=${'"${PROJECT_PREFIX}"'_GROUP_NAMES}
      - DOCKER_USERNAME=user

      #- DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

      - DISPLAY
    # cap_add:
    #   - SYS_PTRACE # Useful for gdb
    volumes:
      - type: bind
        source: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR}
        target: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}' > "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      echo '      - type: volume
        source: venv
        target: /venv' >> "docker-compose.yml"
    fi
    echo '      # - type: volume
      #   source: home-volume
      #   target: ${'"${PROJECT_PREFIX}"'_HOME} # home-volume should be overridable
  '"${APP_NAME}"'2:
    <<: *'"${APP_NAME}"'_anchor' >> "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      echo 'volumes:
  venv:' >> "docker-compose.yml"
    else
      echo '#   volumes:' >> "docker-compose.yml"
    fi
    echo '#   home-volume:' >> "docker-compose.yml"
  else
    echo "docker-compose.yml exists, skipping..."
  fi

  if [ ! -e .dockerignore ]; then
    echo '*' > .dockerignore
    echo '!docker' >> .dockerignore
    echo '!'"${RELATIVE_PATH}" >> .dockerignore

    if [ "${USE_PIPENV}" = "1" ]; then
      echo '!Pipfile' >> .dockerignore
      echo '!Pipfile.lock' >> .dockerignore
    fi
  fi


  if [ ! -e ".gitattributes" ]; then
    echo '#These file types are being explicitly set to linux line endings for windows.
#This is to allow windows user to edit and run these files inside a linux docker
#this list may need additions as time goes on
*.sh eol=lf
*.bsh eol=lf
*.py eol=lf
*.env eol=lf
wrap eol=lf
.justplugins eol=lf
' > .gitattributes
  fi
else
  echo '#include <iostream>
int main()
{
  std::cout << "hello world!" << std::endl;
  return 0;
}' > hi.cpp
fi

###
# Some final bookkeeping...
###

# Add executable permissions
chmod 755 "${JUSTFILE}" "${WRAPFILE}"

# Add .gitignore exceptions
if ! grep -q local.env .gitignore 2>/dev/null; then
  echo local.env >> .gitignore
fi
if ! grep -q local_post.env .gitignore 2>/dev/null; then
  echo local_post.env >> .gitignore
fi

# Remove dummy vsi_common dir to make way for submodule setup
rmdir -p "${VSI_DIR}" 2>/dev/null || :

# ****************************************************************************
# ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
# ****************************************************************************
echo 'Done!'
echo
echo
echo "To complete your git initialization:"
echo
echo "cd '${PROJECT_DIR}'"
if [ ! -e .git ]; then
  echo "git init ." >&3
fi
echo "git submodule add https://github.com/visionsystemsinc/vsi_common.git" \
                       "'${RELATIVE_PATH}'"  >&3
echo "git submodule update --init --recursive" >&3
echo "pushd '${RELATIVE_PATH}'"
echo "git remote set-url origin --push git@github.com:visionsystemsinc/vsi_common.git"
echo "popd"
echo "git add .gitignore .gitmodules README.md '${JUSTFILE}'" \
     "'${SETUPFILE}' '${WRAPFILE}' '${PROJECT_NAME}.env'" >&3
if [ "${USE_DOCKER}" = "1" ]; then
  echo "git add .gitattributes .dockerignore" \
       "docker-compose.yml docker/${APP_NAME}.Dockerfile docker/${APP_NAME}_entrypoint.bsh" >&3
else
  echo "git add hi.cpp" >&3
fi
if [ "${USE_PIPENV}" = "1" ]; then
  echo "git add Pipfile Pipfile.lock" >&3
fi

echo "git commit -m 'Initial commit'"  >&3
echo
echo
echo
echo "To use your new just:"
echo
echo "cd '${PROJECT_DIR}'"
echo ". '${SETUPFILE}'"
echo "just help"
echo
echo "Get started with:"
echo
if [ "${USE_DOCKER}" = "1" ]; then
  echo "just setup"
  echo "just run ${APP_NAME} bash"
else
  echo "just compile"
  echo "just run"
fi
