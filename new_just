#!/usr/bin/env bash

set -eu

# I can tell you WHAT these commands do, not WHY. They redirect stdout to stderr,
# and now the only way to write to stdout is to write to 3
exec 3>&1 # I have NO IDEA why this comes before the next line
exec 1>&2 # Redirect stdout to stderr

: ${JUST_DIR="$(dirname "${BASH_SOURCE[0]}")/"}
if [ -f "${JUST_DIR}/ask_question" ]; then
  source "${JUST_DIR}/ask_question"
fi

#****F* just/new_just
# NAME
#   new_just - Create a new just project
# DESCRIPTION
#   There are many moving pieces to set up a working just project and use
#   all the features. Just getting started is hard, without knowing where to
#   start. This script will create all the files necessary to have a new
#   docker-compose based just project up and running.
# USAGE
#   By default, new_just will prompt the user for questions on the initial
#   setup parameters. Default values are supplied for all questions, and enter
#   can be pressed to accept all the defaults. All of the questions can be set
#   using environment variables, making them scriptable.
#
#   After new_just is called, a few git commands need to be called. This is not
#   done for you, in case it will break your existing repository. These
#   commands are printed out on stdout, while everything else is printed on
#   stderr, making them scriptable.
#
#   If any of the files written to exist, they are not overwritten, and a warning
#   message is printed out.
# SEE ALSO
#   new_just/PROJECT_DIR, new_just/PROJECT_NAME, new_just/PROJECT_PREFIX
#   new_just/REPO_NAME, new_just/JUSTFILE, new_just/WRAPFILE, new_just/SETUPFILE
#   new_just/JUST_COMMON_DIR
# AUTHOR
#   Andy Neff
#***

echo "Setting up a new project to use J.U.S.T."
echo

#****d* new_just/PROJECT_DIR
# NAME
#   PROJECT_DIR - The main project directory
# DESCRIPTION
#   The project directory is typically the root directory of the main git
#   repository. This is where all the just files will be stored by default.
#
#   The value can be customized when prompted by new_just. The default value
#   is the current working directory. The question can be skipped by setting
#   the environment variable PROJECT_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_DIR="$(read -r -p "Project directory [${PWD}] " x; echo "$x")"}
if [ "${PROJECT_DIR}" == "" ]; then
  PROJECT_DIR="${PWD}"
else
  mkdir -p "${PROJECT_DIR}"
  PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
fi

#****d* new_just/PROJECT_NAME
# NAME
#   PROJECT_NAME - Name of the just project being created
# DESCRIPTION
#   The PROJECT_NAME is used to set the project environment file name used by
#   source_environment_files. Specifically: ${PROJECT_DIR}/${PROJECT_NAME}.env
#   PROJECT_NAME is also used for for determining other default values.
#
#   The value can be customized when prompted by new_just. The default value
#   is basename of the PROJECT_DIR. The question can be skipped by setting the 
#   environment variable PROJECT_NAME to the desired value.
# SEE ALSO
#   just/source_environment_files
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_NAME="$(read -r -p "Project name [$(basename "${PROJECT_DIR}")] " x; echo "$x")"}
if [ "${PROJECT_NAME}" == "" ]; then
  PROJECT_NAME="$(basename "${PROJECT_DIR}")"
fi


#****d* new_just/PROJECT_PREFIX
# NAME
#   PROJECT_PREFIX - The prefix of environment variables for this project
# DESCRIPTION
#   Used to set the value of JUST_PROJECT_PREFIX. Must contain only valid bash
#   variable-name characters: [A-Z0-9_]+
#
#   Does not need the trailing _ included, this will always be added when it is
#   used.
#
#   The value can be customized when prompted by new_just. The default value is
#   uppercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable PROJECT_PREFIX to the desired value.
# SEE ALSO
#   just/JUST_PROJECT_PREFIX
#***
default=$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
: ${PROJECT_PREFIX="$(read -r -p "Project variable prefix [${default}] " x; echo $x)"}
if [ "${PROJECT_PREFIX}" == "" ]; then
  PROJECT_PREFIX=${default}
else
  PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
fi

#****d* new_just/REPO_NAME
# NAME
#   REPO_NAME - Name of docker repository where images are stored
# DESCRIPTION
#   When docker images are built, they need to be named, or else the only way to
#   access them is inconveniently though sha256 checksums.
#
#   The REPO_NAME should be an untagged docker repository name. Tag names will
#   be added for each service. Docker image names must match the regex
#   [a-zA-Z0-9][a-zA-Z0-9_.-]* or else docker will error
#
#   The value can be customized when prompted by new_just. The default value is
#   lowercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable REPO_NAME to the desired value.
# AUTHOR
#   Andy Neff
#***
default=$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
: ${REPO_NAME="$(read -r -p "Docker Repo for images [${default}] " x; echo $x)"}
if [ "${REPO_NAME}" == "" ]; then
  REPO_NAME=${default}
else
  REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
fi


#****d* new_just/JUSTFILE
# NAME
#   JUSTFILE - Name of the justfile used
# DESCRIPTION
#   The default just file in just is "Justfile". If this is changed, the only
#   way to inform just of this is by setting it in the SETUPFILE. This will be
#   added to the SETUPFILE by new_just if anything other than the default is
#   used.
#
#   The value can be customized when prompted by new_just. The default value
#   is Justfile. The question can be skipped by setting the environment variable
#   JUSTFILE to the desired value.
# SEE ALSO
#   new_just/SETUPFILE, just/Justfile
# AUTHOR
#   Andy Neff
#***
: ${JUSTFILE="$(read -r -p "Just file name [Justfile] " x; echo "$x")"}
if [ "${JUSTFILE}" == "" ]; then
  JUSTFILE="Justfile"
else
  JUSTFILE="$(basename ${JUSTFILE})"
fi


#****d* new_just/SETUPFILE
# NAME
#   SETUPFILE - Name of the setup file sourced to setup just environment
# DESCRIPTION
#   The setup file is used to make the minimal necessary changes to the
#   environment so that just works. This includes adding paths and setting a
#   few environment variables. This is meant to be as unobtrusive as possible.
#
#   This file needs to be sourced every time a new terminal session is opened.
#   The only time the setup script is not needed is when calling the WRAPFILE.
#
#   The value can be customized when prompted by new_just. The default value is
#   setup.env. The question can be skipped by setting the environment variable
#   SETUPFILE to the desired value.
# SEE ALSO
#   new_just/WRAPFILE
# AUTHOR
#   Andy Neff
#***
: ${SETUPFILE="$(read -r -p "Environment setup script file name [setup.env] " x; echo "$x")"}
if [ "${SETUPFILE}" == "" ]; then
  SETUPFILE="setup.env"
else
  SETUPFILE="$(basename ${SETUPFILE})"
fi

#****d* new_just/WRAPFILE
# NAME
#   WRAPFILE - The wrap filename that runs any command in the just environment
# DESCRIPTION
#   The wrap file can be used to run any command in the full just environment or
#   to enter a bash session in this environment.
#
#   The value can be customized when prompted by new_just. The default value is
#   wrap. The question can be skipped by setting the environment variable
#   WRAPFILE to the desired value.
# SEE ALSO
#   just/Just_wrap
# AUTHOR
#   Andy Neff
#***
: ${WRAPFILE="$(read -r -p "Wrap script file name [wrap] " x; echo "$x")"}
if [ "${WRAPFILE}" == "" ]; then
  WRAPFILE="wrap"
else
  WRAPFILE="$(basename ${WRAPFILE})"
fi

#****d* new_just/JUST_COMMON_DIR
# NAME
#   JUST_COMMON_DIR - Location of the just submodule
# DESCRIPTION
#   The just repository is necessary for virtually all of the just
#   capabilities. The correct way to deal with this is to add just as a
#   submodule for your main project. This tells just were this submodule is
#   located.
#
#   The value can be customized when prompted by new_just. The default value is
#   external/just. The question can be skipped by setting the environment
#   variable JUST_COMMON_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${JUST_COMMON_DIR="$(read -r -p "Just common module path [./external/just] " x; echo "$x")"}
if [ "${JUST_COMMON_DIR}" == "" ]; then
  JUST_COMMON_DIR="${PROJECT_DIR}/external/just"
else
  JUST_COMMON_DIR="$(cd "${PROJECT_DIR}";
             mkdir -p "${JUST_COMMON_DIR}";
             cd "${JUST_COMMON_DIR}";
             pwd)"
fi

echo "Summary"
echo "======="
printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
printf "%-40s | %-40s\n" "Wrap script" "${WRAPFILE}"
printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
printf "%-40s | %-40s\n" "Just Common Directory" "${JUST_COMMON_DIR}"
echo
# Ask y/n question
if command -v ask_question &>/dev/null; then
  ask_question "Continue?" CONTINUE y
else
  if [ "${CONTINUE-1}" != "1" ]; then
    read -r -p "Press enter to continue"
  fi
  CONTINUE=1
fi

if [ "${CONTINUE}" != "1" ]; then
  exit 1
fi

# Setup done, start making the new environment

# RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${JUST_COMMON_DIR}', '${PROJECT_DIR}'))")"
RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${JUST_COMMON_DIR}','${PROJECT_DIR}');")"

# Make project dir
mkdir -p "${PROJECT_DIR}"
cd "${PROJECT_DIR}"

# Make wrap script
if [ ! -e "${WRAPFILE}" ]; then
  echo '#!/usr/bin/env bash' > "${WRAPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${WRAPFILE}"
  fi
  echo ': "$(dirname "${BASH_SOURCE[0]}")"
. "${_}"/'"${RELATIVE_PATH}"'/Just_wrap "${_}"/'"${PROJECT_NAME}"'.env ${@+"${@}"}' >> "${WRAPFILE}"
else
  echo "${WRAPFILE} exists, skipping..."
fi

# Make setup script
if [ ! -e "${SETUPFILE}" ]; then
  echo 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
unset JUST_VERSION
source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${RELATIVE_PATH}"'/env.bsh"' > "${SETUPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${SETUPFILE}"
  fi
else
  echo "${SETUPFILE} exists, skipping..."
fi


# Make the project settings file

if [ ! -e "${PROJECT_NAME}.env" ]; then
  echo 'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
'"${PROJECT_PREFIX}"'_CWD="${CWD-"$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"}"

: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

: ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
: ${'"${PROJECT_PREFIX}"'_USERNAME=$(id -u -n)}
: ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
: ${'"${PROJECT_PREFIX}"'_GIDS=$(id -G)}

: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR="${'"${PROJECT_PREFIX}"'_CWD}"}
: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER="/src"}

if [ "${VSI_OS}" = "linux" ]; then
  '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
      ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
fi

'"${PROJECT_PREFIX}"'_SOMEAPPNAME_VOLUMES=(
    "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}:${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}"
    ${'"${PROJECT_PREFIX}"'_SOMEAPPNAME_VOLUMES+"${'"${PROJECT_PREFIX}"'_SOMEAPPNAME_VOLUMES[@]}"})

' > "${PROJECT_NAME}.env"

else
  echo "${PROJECT_NAME}.env exists, skipping..."
fi

# Make default README
if [ ! -e "README.md" ]; then
  echo 'Just usage:

```
source "'"${SETUPFILE}"'"
just help
```
' > README.md
else
  echo "README.md exists, skipping..."
fi

# Make Just file
if [ ! -e "${JUSTFILE}" ]; then
  echo '#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then #If being sourced
  set -euE
fi

source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${WRAPFILE}"'"
cd "${'"${PROJECT_PREFIX}"'_CWD}"

source "${JUST_DIR}/docker_functions.bsh"

function caseify()
{
  local just_arg=$1
  shift 1
  case ${just_arg} in
    build) # Build Docker image
      Docker-compose build base_someappname
      Docker-compose build
      ;;
    run_someappname) # Run someappname 1
      Just-docker-compose run someappname ${@+"${@}"}
      extra_args+=$#
      ;;
    run_someappname2) # Run someappname 2
      Just-docker-compose run someappname2 ${@+"${@}"}
      extra_args+=$#
      ;;
    *)
      defaultify "${just_arg}" ${@+"${@}"}
      ;;
  esac
}

if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi
' > "${JUSTFILE}"
else
  echo "${JUSTFILE} exists, skipping..."
fi

mkdir -p docker

# Make default dockerfiles
if [ ! -e "docker/base_someappname.Dockerfile" ]; then
  echo 'FROM alpine:3.6

SHELL ["sh", "-euxvc"]

RUN apk --no-cache add curl

RUN curl -L https://github.com/krallin/tini/releases/download/v0.10.0/tini -o /usr/local/bin/tini; \
    chmod +x /usr/local/bin/tini; \
    echo "1361527f39190a7338a0b434bd8c88ff7233ce7b9a4876f3315c22fce7eca1b0  /usr/local/bin/tini" | sha256sum -c -

RUN curl -L https://github.com/tianon/gosu/releases/download/1.10/gosu-amd64 -o /usr/local/bin/gosu; \
    chmod +x /usr/local/bin/gosu; \
    echo "5b3b03713a888cee84ecbf4582b21ac9fd46c3d935ff2d7ea25dd5055d302d3c  /usr/local/bin/gosu" | sha256sum -c -

RUN apk --no-cache add bash

ADD '"${RELATIVE_PATH}"' /just
ADD docker/someappname_entrypoint.bsh /
RUN chmod 755 /someappname_entrypoint.bsh

ENTRYPOINT ["/someappname_entrypoint.bsh"]

CMD ["someappname"]' > docker/base_someappname.Dockerfile
else
  echo "docker/base_someappname.Dockerfile exists, skipping..."
fi

if [ ! -e "docker/someappname.Dockerfile" ]; then
  echo "FROM ${REPO_NAME}:base_someappname" > docker/someappname.Dockerfile
else
  echo "docker/someappname.Dockerfile exists, skipping..."
fi

if [ ! -e "docker/someappname_entrypoint.bsh" ]; then
  echo '#!/usr/bin/env bash

set -eu

if [ "${ALREADY_RUN_ONCE+set}" != "set" ]; then
  # create the user and associated groups and handle nfs symlinks
  bash -eu /just/docker_entrypoint.bsh

  # Rerun entrypoint as user now, (skipping the root part via ALREADY_RUN_ONCE)
  ALREADY_RUN_ONCE=1 exec gosu ${DOCKER_USERNAME} $0 ${@+"${@}"}
fi

source "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/wrap"
source "${JUST_DIR}/docker_functions.bsh"
filter_docker_variables

if [ "$1" == "someappname" ]; then
  echo "Run someappname here: ${@+${@}}"
else
  exec "${@}"
fi' > docker/someappname_entrypoint.bsh
else
  echo "docker/someappname_entrypoint.bsh exists, skipping..."
fi


# Make default docker-compose.yml
if [ ! -e "docker-compose.yml" ]; then
  echo 'version: "3.2"

services:
  base_someappname:
    build:
      context: .
      dockerfile: docker/base_someappname.Dockerfile
    image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:base_someappname
  someappname: &someappname_anchor
    build:
      context: .
      dockerfile: docker/someappname.Dockerfile
    # prevent different users from clobbering each others images
    image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:someappname_${'"${PROJECT_PREFIX}"'_USERNAME}
    environment:
      # Variables for docker_entrypoint.bsh
      - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
      - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
      - DOCKER_USERNAME=user

      #- DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

      - DISPLAY
    cap_add:
      - SYS_PTRACE #Useful for gdb
#    volumes:
#      - home-volume:${'"${PROJECT_PREFIX}"'_HOME} #home-volume should be overridable
  someappname2:
    <<: *someappname_anchor
#volumes:
#  home-volume:
' > "docker-compose.yml"
else
  echo "docker-compose.yml exists, skipping..."
fi

###
# Some final bookkeeping...
###

# Add executable permissions
chmod 755 "${JUSTFILE}" "${WRAPFILE}"

if [ ! -e .dockerignore ]; then
  touch .dockerignore
fi

# Add .gitignore exceptions
if ! grep -q local.env .gitignore 2>/dev/null; then
  echo local.env >> .gitignore
fi
if ! grep -q local_post.env .gitignore 2>/dev/null; then
  echo local_post.env >> .gitignore
fi

if [ ! -e ".gitattributes" ]; then
  echo '#These file types are being explicitly set to linux line endings for windows.
#This is to allow windows user to edit and run these files inside a linux docker
#this list may need additions as time goes on
*.sh eol=lf
*.bsh eol=lf
*.py eol=lf
*.env eol=lf
wrap eol=lf
.justplugins eol=lf
' > .gitattributes
fi

# Remove dummy just dir to make way for submodule setup
rmdir -p "${JUST_COMMON_DIR}" 2>/dev/null || :

# ****************************************************************************
# ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
# ****************************************************************************
echo 'Done!'
echo
echo
echo "To complete your git initialization:"
echo
echo "cd '${PROJECT_DIR}'"
if [ ! -e .git ]; then
  echo "git init ." >&3
fi
echo "git submodule add git@github.com:visionsystemsinc/just.git" \
                       "'${RELATIVE_PATH}'"  >&3
echo "git add .gitattributes .gitignore .dockerignore .gitmodules README.md '${JUSTFILE}'" \
     "'${SETUPFILE}' '${WRAPFILE}' '${PROJECT_NAME}.env'" \
     "docker-compose.yml docker/someappname.Dockerfile docker/someappname_entrypoint.bsh" \
     "docker/base_someappname.Dockerfile" >&3
echo "git commit -m 'Initial commit'"  >&3
echo
echo
echo
echo "To use your new just:"
echo
echo "cd '${PROJECT_DIR}'"
echo ". '${SETUPFILE}'"
echo "just help"
echo
echo "Get started with:"
echo
echo "just build"
echo "just run someappname bash"
