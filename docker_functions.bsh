#!/usr/bin/env false
#Source this script for docker specific helper functions for just or other

: ${JUST_DIR="$(dirname "${BASH_SOURCE[0]}")/"}
source "${JUST_DIR}/mount_tools.bsh"
source "${JUST_DIR}/docker_compose_override"
source "${JUST_DIR}/dir_tools.bsh"

#****F* just/docker_functions.bsh
# NAME
#   docker_functions.bsh - Set of functions to make using dockers easier
# AUTHOR
#   Andy Neff
#***

#****d* docker_functions.bsh/DOCKER
# NAME
#   DOCKER - Name/path of docker executable
# SYNOPSIS
#   Instead of hard-coding "docker" everywhere, use the variable DOCKER so that
#   when the need comes, it is easier to switch which executable gets called
# AUTHOR
#   Andy Neff
#***
: ${DOCKER=docker}
#****d* docker_functions.bsh/NVIDIA_DOCKER
# NAME
#   NVIDIA_DOCKER - Name/path of nvidia-docker executable
# SYNOPSIS
#   Instead of hard-coding "nvidia-docker" everywhere, use the variable
#   NVIDIA_DOCKER so that when the need comes, it is easier to switch which
#   executable gets called. Default to DOCKER if nvidia-docker executable is not
#   in the path (hash-able)
# AUTHOR
#   Andy Neff
#***
: ${NVIDIA_DOCKER=nvidia-docker}
if ! hash ${NVIDIA_DOCKER} 2> /dev/null; then
  NVIDIA_DOCKER=${DOCKER}
fi


#****d* docker_functions.bsh/is_dir_and_not_exist
# NAME
#   is_dir_and_not_exist - See if the string looks like a non-existing directory
# DESCRIPTION
#   Docker currently creates directories that do not exist when mounting. This
#   has a few bad side effects, such as the directories end up being own by root.
#   In order to work around this "bug", this function identifies if docker will
#   assume a string is a directory/file or an internal mount.
# INPUTS
#   $1 - String to check
# OUTPUT
#   Returns 0 for is a directory, and 1 for not a directory (is an internal
#   mount)
# EXAMPLE
#   is_dir_and_not_exist this_looks_like_an_internal_volume
#   is_dir_and_not_exist ./this_looks/like_a/directory
#   is_dir_and_not_exist /this_also_looks/like_a/directory
#
#   if is_dir_and_not_exist ${my_mount}; then
#     mkdir -p ${my_mount}
#   fi
# AUTHOR
#   Andy Neff
# SEE ALSO
#   docker_functions.bsh/docker_sanitize_volume
#***
function is_dir_and_not_exist()
{
 local dir_name="$1"

 if ( [ "${dir_name:0:1}" == "/" ] || \
      ( (( ${#dir_name} >= 2 )) && ( [ "${dir_name:0:2}" == "./" ] || [ "${dir_name:1:1}" == ":" ] ) ) ) && \
    [ ! -d "${dir_name}" ] && [ ! -e "${dir_name}" ]; then
    return 0 #TRUE!
 fi
 return 1 #False :(
}


#****f* docker_functions.bsh/container_get_label
# NAME
#   container_get_label - Get a label value from a docker container
# INPUTS
#   $1 - Container name
#   $2 - Label name
# OUTPUT
#   stdout - Prints out the label value (and evaluates environment variables)
#   Return 1 if label is blank (possibly not set), 0 for label found
# NOTES
#   Requires perl be installed
# BUGS
#   Cannot determine the differece between blank and unset lables. See
#   container_has_label to handle that ambiguity.
# AUTHOR
#   Andy Neff
#***
function container_get_label()
{ # All labels go through a perl filter that evaluate %name% using exported
  # environment variables. This won't work on unexported variables
  local value=$(docker inspect -f "{{index .Config.Labels \"$2\"}}" $1)
  if [ "${value}" == "" ]; then
    return 1
  fi

  echo "${value}" | perl -wpe 's#\%?(\w+)\%# $ENV{$1} // $& #ge;'

  return 0
}


#****f* docker_functions.bsh/container_has_label
# NAME
#   container_has_label - Check to see if a container contains a certain label
# SYNOPSIS
#   docker_functions.bsh/container_get_label can not tell whether a container
#   has a label or not when the label is blank. The go template filter does not
#   differentiate. This will verify that a blank label is set or unset.
# INPUTS
#   $1 - Container name
#   $2 - Label name
# OUTPUT
#   Return 1 for label is unset, 0 for label is set
# NOTES
#   Requires jq be installed
# AUTHOR
#   Andy Neff
#***
function container_has_label()
{
  if [ "$(docker inspect -f '{{json .Config.Labels }}' $1 | \
          jq .\[\"$2\"\])" == "null" ]; then
    return 1
  else
    return 0
  fi
}

#****f* docker_functions.bsh/docker_premkdir
# NAME
#   docker_premkdir - Convenient wrapper to deal with the MINGW screw ups
# DESCRIPTION
#   Preempt one of docker's annoying behaviors of creating directories that
#   don't exist as root:root, and make the directory yourself.
#
#   When the argument is a docker volume, nothing should happen. Docker auto
#   creates those just fine.
# INPUTS
#   $1 - host directory name or docker volume
# NOTES
#   Always creates the directory with 777 permission. This is to maximize the
#   chances that it works. If you don't want this, the easy solution is to
#   create the directory yourself. This is more of an emergency catch. For this
#   reason, when the directory is created, a message is printed.
#
#   When a directory doesn't exist, it is assumed it is a directory, and not a
#   file because this is the same behavior as docker.
# AUTHOR
#   Andy Neff
#***
function docker_premkdir()
{
  local host_dir="${1}"

  # In Windows (only), \'s are converted to /'s
  if [ "${OS-notwindows}" == "Windows_NT" ]; then
    host_dir="${host_dir//\\//}"
  fi

  if is_dir_and_not_exist "${host_dir}"; then #if not a file or dir
    echo "Missing directory ${host_dir} created with 777" >&2
    mkdir -p "${host_dir}" #make the dir
    chmod 777 "${host_dir}" #Blow open permissions
  fi
}

#****f* docker_functions.bsh/docker_host_dir
# NAME
#   docker_host_dir - Normalize POSIX path to native path
# DESCRIPTION
#   On Windows:
#     Converts /d/foo/bar to D:\foo\bar using cygpath
#   On everything else in the world:
#     WYSIWYG
# INPUTS
#   $1 - Directory name
# OUTPUT
#   stdout - Converted directory name
# AUTHOR
#   Andy Neff
#***
function docker_host_dir()
{
  if [ "${OS-notwindows}" == "Windows_NT" ] && command -v cygpath &> /dev/null ; then
    echo "$(cygpath -w "$1")"
    #Bash 4 in mingw64 includes cygpath for some reason
    #Cygpath converts / -> \
    #^/{single letter} -> {single letter}:\
    #^/{single letter}/ -> {single letter}:\\ #bug? No longer on v2.9.0!
    #else ^/ -> {git_directory}
  else
    echo "$1"
  fi
}



#****f* docker_functions.bsh/docker_parse_volume_string
# NAME
#   docker_parse_volume_string - Split the docker volume string up
# DESCRIPTION
#   Docker volume strings can contain optional flags, and depending on windows
#   or POSIX operating systems, have different rules, etc... This function will
#   universially split the string up.
# INPUTS
#   $1 - The volume string
# OUTPUT
#   volume_host - Host path part of the string
#   volume_docker - Docker path part of the string
#   volume_flags - Extra optional flags part of the string. May be empty
#   Returns 1 if regex is not matched, else return 0
# NOTES
#   Based off of docker 17.12 syntax. If new flags are added, the regex must be
#   updated
#
#   Not actually a bug, but a string like "d:/test:ro" would be parsed as host
#   path "D:\test" and docker path "ro", NOT internal volume "d", docker path
#   "/test", and flag read-only. This is not a bug because you can't have a
#   single letter docker volume, so this shouldn't work anyways.
# AUTHOR
#   Andy Neff
#***
function docker_parse_volume_string()
{
  local volume_pattern='^(([a-zA-Z]:[/\]+)?[^:]*):(([a-zA-Z]:[/\]+)?[^:]*)((:ro|:rw|:z|:Z|:r?shared|:r?slave|:r?private|:delegated|:cached|:consistent|:nocopy)*)$'
  # C:\*, c:/* .* /* - '^(([a-zA-Z]:[/\]+)?[^:]*)'
  # :
  # First part again
  # Flags
  # Break the volume string up into BASH_REMATCH
  # 1 - Host path
  # 3 - Docker path
  # 5 - flags

  if [[ ${1} =~ ${volume_pattern} ]]; then
    volume_host="${BASH_REMATCH[1]}"
    volume_docker="${BASH_REMATCH[3]}"
    volume_flags="${BASH_REMATCH[5]}"
    return 0
  else
    return 1
  fi
}

#****f* docker_functions.bsh/docker_sanitize_volume
# NAME
#   docker_sanitize_volume - Create a directory before docker gets a chance to
# DESCRIPTION
#   A number of things can go wrong with something as simple as mounting a
#   directory. If the directory doesn't exist, root will end up owning the
#   directory (which is often not desired). Also, on MINGW Linux/Windows path
#   expansion ends up being an error to docker on windows. So this function will
#   take care of both of these problems in an OS agnostic way.
# INPUTS
#   $1 - The host directory/volume name
#   [$2] - The docker directory (optional. If omitted, copies host directory)
# OUTPUT
#   stdout - The argument that should go with the -v to docker for mounting
# USAGE
#   Mainly fo the docker and docker-compose CLI -v flags
# BUGS
#   The docker directory is not optional if the host mount is a volume
# AUTHOR
#   Andy Neff
#***
function docker_sanitize_volume()
{
  if (( $# < 2 )); then
    set -- "$1" "$1"
  fi

  local host_dir
  local docker_dir

  if [ "${OS-notwindows}" == "Windows_NT" ]; then
    host_dir="$(docker_host_dir "${1}")"
    # Add an extra / so that mingw doesn't attempt path conversion
    docker_dir="/$2"
  else
    host_dir="$1"
    docker_dir="$2"
  fi

  # Create the directory before docker
  docker_premkdir "${host_dir}"

  echo "${host_dir}:${docker_dir}"
}

#****f* docker_functions.bsh/parse-docker
# NAME
#   parse-docker - Parse docker arguments
# DESCRIPTION
#   Parse docker's arguments and split up information (See OUTPUT)
# INPUTS
#   $1.. - Arguments to be sent to docker command
# OUTPUT
#   docker_args - Arguments to docker, before the docker subcommand (run, up,
#                 down, etc...)
#   docker_command - Docker command specified
#   docker_command_args - Arguments for the specified command
# USAGE
#   Typically, in the calling function, you will define all the output variables
#   as local, so that they are captured by the calling function only.
#
#   Original command can be thought of as:
#     docker "${docker_args[@]}" "${docker_command}" "${docker_command_args[@]}"
# AUTHOR
#   Andy Neff
#***
function parse-docker()
{
  docker_args=()
  docker_command_args=()

  while (( $# )); do
    case "$1" in
      -H*|-l*|\
      --config=*|--host=*|--log-level=*|--tlscacert=*|--tlscert=*|--tlskey=*|\
      -D|-v|\
      --debug|--tls|--version|--tlsverify)
        docker_args+=("$1")
        shift 1
        ;;
      -H|-l|\
      --config|--host|--log-level|--tlscacert|--tlscert|--tlskey)
        docker_args+=("$1" "$2")
        shift 2
        ;;
      # Anything else must be a docker compose command.
      *)
        docker_command="$1"
        shift 1
        docker_command_args=(${@+"${@}"})
        break
        ;;
    esac
  done
}

#****f* docker_functions.bsh/Exec-Nvidia-Docker
# NAME
#   Exec-Nvidia-Docker - Version of Docker for Nvidia and exec's
# AUTHOR
#   Andy Neff
#***
function Exec-Nvidia-docker(){ DOCKER_EXEC=1 Nvidia-Docker "${@}";}
#****f* docker_functions.bsh/Nvidia-Docker
# NAME
#   Nvidia-Docker - Version of Docker for Nvidia
# AUTHOR
#   Andy Neff
#***
function Nvidia-docker(){ DOCKER="${NVIDIA_DOCKER}" Docker "${@}";}
#****f* docker_functions.bsh/Exec-Docker
# NAME
#   Exec-Docker - Version of Docker that exec's command rather than call
# AUTHOR
#   Andy Neff
#***
function Exec-Docker(){ DOCKER_EXEC=1 Docker "${@}";}
#****f* docker_functions.bsh/Docker
# NAME
#   Docker - Helper function to execute the right docker command, or just dryrun
# DESCRIPTION
#   Instead of calling the docker command directly, the Docker command should be
#   called instead (for all dryrun-able activities. Simple commands like
#   inspect, ps, etc. don't make as much sense to dryrun, as the reset of the
#   script will never be executed, thus rendering dryrun useless.)
# INPUTS
#   DRYRUN - Optional variable inserted at the beginning of all docker commands.
#            Useful for setting to "echo" or similar for dryrun mode
#   DOCKER_EXTRA_ARGS - Array of extra arguments inserted after docker but
#                       before the docker subcommand
#   DOCKER_EXTRA_{subcommand}_ARGS - Extra arguments inserted right after the
#                                    docker subcommand
#   DOCKER_AUTOREMOVE - Automatically add the --rm flag to docker run commands
#   $1.. - Arguments to be sent to docker command
# OUTPUT
#   Runs docker command
# AUTHOR
#   Andy Neff
#***
function Docker()
{
  local docker_args
  local docker_command
  local docker_command_args

  parse-docker ${@+"${@}"}

  _Docker
}

function _Docker()
{
  local docker_extra_command_args=()
  local cmd=(${DRYRUN} ${DOCKER})
  local extra_args_var

  if [ "${docker_command}" = "run" ] && [ "${DOCKER_AUTOREMOVE-1}" == "1" ]; then
    docker_extra_command_args+=(--rm)
  fi

  #Indirect add DOCKER_COMPOSE_EXTRA_{COMMAND}_ARGS
  extra_args_var=$(tr '[a-z]' '[A-Z]' <<< "${docker_command}")
  extra_args_var="DOCKER_EXTRA_${extra_args_var}_ARGS[@]"
  docker_extra_command_args+=(${!extra_args_var+"${!extra_args_var}"})

  cmd=("${cmd[@]}"
      ${docker_args+"${docker_args[@]}"}
      ${DOCKER_EXTRA_ARGS+"${DOCKER_EXTRA_ARGS[@]}"}
      ${docker_command}
      ${docker_extra_command_args+"${docker_extra_command_args[@]}"}
      ${docker_command_args+"${docker_command_args[@]}"})

  if [ "${DOCKER_EXEC-}" == "" ] || [ "${DRYRUN}" != "" ]; then
    "${cmd[0]}" "${cmd[@]:1}"
    return $?
  else
    exec "${cmd[@]}"
  fi
}

######################
### docker-compose ###
######################

#****d* docker_functions.bsh/DOCKER_COMPOSE
# NAME
#   DOCKER_COMPOSE - Name/path of docker-compose executable
# SYNOPSIS
#   Instead of hard-coding "docker-compose" everywhere, use the variable
#   DOCKER_COMPOSE so that when the need comes, it is easier to switch which
#   executable gets called
# AUTHOR
#   Andy Neff
#***
: ${DOCKER_COMPOSE=docker-compose}

#****f* docker/docker-compose-volumes
# NAME
#   docker-compose-volumes - Get volume flags from docker-compose config
# PURPOSE
#   Reformats the output from docker-compose config to an array with -v flags
#   for use in passing to another docker or docker-compose run command.
# INPUTS
#   $1 - name of service of interest
#   [$2] - prefix to volume names
# OUTPUT
#   DOCKER_VOLUME_FLAGS - Array of the docker flags, including necessary -v's
# EXAMPLE
#  docker-compose.yml
#    version: "3.2"
#    services:
#      nb:
#        image : blah
#        volumes:
#          - /tmp:/mnt
#          - test:/opt
#    volumes:
#      test:
#
#  docker-compose-volumes nb test_prefix_ < <(docker-compose config)
#  # Or
#  # docker-compose-volumes nb <<< "$(docker-compose config)"
#
#  declare -p DOCKER_VOLUME_FLAGS
#  > declare -a DOCKER_VOLUME_FLAGS='([0]="-v" [1]="/tmp:/mnt:rw" [2]="-v"
#                                     [3]="test_prefix_test:/opt")'
# BUGS
#   Currently only works on volume short format
# NOTES
#   Useful for working around docker/compose#4728
# AUTHOR
#   Andy Neff
#***
function docker-compose-volumes()
{
  local OLD_IFS="${IFS}"
  local PREFIX="${2-}"
  IFS=$'\n'
  DOCKER_VOLUME_FLAGS=(\
    $(sed -nE '/^services:$/b services
               d
               :services
               n
               # Search for the service entry
               /^  '"${1}"':$/b found
               /^ /b services
               d
               :found
               # Clear pattern buffer and read next line
               n
               # Read volumes: found
               /^    volumes:/b volumes
               # Search all of the service entry
               /^    /b found
               # Volumes were not found, give up
               d
               :volumes
               # Read in a new line
               n
               # Match this new line for an indented(4) list
               /^      -/{
                 s|^      - ([^./])|      - '"${PREFIX}"'\1|
                 # Add these lines to the hold buffer
                 H
                 # Repeat
                 b volumes
               }
               # Switch the hold and pattern buffer
               x
               # Format indented list to look like docker flags
            '$'s|\\n      - |\\\n-v\\\n|g''
               #s|^\n|| # Remove the first blank line - Not needed with array magic
               # Print out that pretty pattern!
               p'))
  IFS="${OLD_IFS}"
}

#****f* docker_functions.bsh/parse-docker-compose
# NAME
#   parse-docker-compose - Parse docker-compose arguments
# DESCRIPTION
#   Parse docker-compose's arguments and pull out a few important pieces of
#   information (See OUTPUT)
# INPUTS
#   [JUST_DOCKER_COMPOSE_DIR] - By default, the docker-compose files will start
#                               being searched for in the JUSTFILE directory,
#                               and search up the parent dirs until / is hit.
#                               This should give a more predictable behavior when
#                               running just from any subdirectory from the
#                               project. However, if you wish to the disable this
#                               behavior and start searching for a docker compose
#                               file from the current directory where "just" is
#                               called, then set to an empty string. You can also
#                               set to a specific directory to start searching
#                               from within that directory.
#   $1.. - Arguments to be sent to docker-compose command
# OUTPUT
#   docker_compose_args - Arguments to docker-compose, before the docker-compose
#                         command (run, up, down, etc...)
#   docker_compose_command - Docker compose command specified
#   docker_compose_command_args - Arguments for the specified command
#   docker_compose_files - Array of docker compose files that are used
#   docker_compose_project_name - Docker compose project name
# USAGE
#   Typically, in the calling function, you will define all the output variables
#   as local, so that they are captured by the calling function only.
#
#   Original command can be thought of as:
#     docker-compose "${docker_compose_args[@]}" "${docker_compose_command}" \
#                    "${docker_compose_command_args[@]}"
# EXAMPLE
#   To start searching for docker-compose.yml in directory where "just" is called
#   Justfile
#
#     target) # Test target
#       JUST_DOCKER_COMPOSE_DIR="" Just-docker-compose run target
#       ;;
#
#   To change the default search location for a project, in the project env file
#   add
#
#   : ${JUST_DOCKER_COMPOSE_DIR="${PROJECT_CWD}/docker_dir"}
#
# NOTES
#   Since the -f argument overrides all other forms of choosing the compose file
#   the docker_compose_args are modified to include the -f notation, if the
#   other methods were used. This will not change the behavior of the
#   docker-compose command run, but will make adding additional compose files
#   a lot easier
# AUTHOR
#   Andy Neff
#***
function parse-docker-compose()
{
  local compose_file

  docker_compose_files=()
  docker_compose_args=()
  docker_compose_project_name=

  while (( $# )); do
    case "$1" in
      -f|-p|-H)
        docker_compose_args+=("$1" "$2")
        case "$1" in
          -f)
            docker_compose_files+=("$2")
            ;;
          -p)
            docker_compose_project_name="$2"
            ;;
        esac
        shift 2
        ;;
      -f*|-p*|-H*)
        docker_compose_args+=("$1")
        case "$1" in
          -f*)
            docker_compose_files+=("${1:2:${#1}-2}")
            ;;
          -p*)
            docker_compose_project_name="${1:2:${#1}-2}"
            ;;
        esac
        shift 1
        ;;
      --file=*|--project-name=*|--host=*|\
      --tlscacert=*|--tlscert=*|--tlskey=*|--project-directory=*|\
      --no-ansi|-v|--verbose|--tls|--skip-hostname-check|--tlsverify)
        docker_compose_args+=("$1")
        case "$1" in
          --file=*)
            docker_compose_files+=("${1:7:${#1}-7}")
            ;;
          --project-name=*)
            docker_compose_project_name="${1:15:${#1}-15}"
            ;;
        esac
        shift 1
        ;;
      --file|--project-name|--host|\
      --tlscacert|--tlscert|--tlskey|--project-directory)
        docker_compose_args+=("$1" "$2")
        case "$1" in
          --file)
            docker_compose_files+=("${2}")
            ;;
          --project-name)
            docker_compose_project_name="${2}"
            ;;
        esac
        shift 2
        ;;
      # Anything else must be a docker compose command.
      *)
        docker_compose_command="$1"
        shift 1
        docker_compose_command_args=(${@+"${@}"})
        break
        ;;
    esac
  done

  if [ ${#docker_compose_files[@]} -eq 0 ]; then
    local OLD_IFS="${IFS}"
    local IFS="$(compose_path_separator)"
    docker_compose_files+=(${COMPOSE_FILE+"${COMPOSE_FILE[*]}"})
    for compose_file in ${docker_compose_files+"${docker_compose_files[@]}"}; do
      docker_compose_args+=(-f "${compose_file}")
    done
    IFS="${OLD_IFS}"
  fi

  if [ ${#docker_compose_files[@]} -eq 0 ]; then
    local file_matches
    # This is one of the few times the directory you are in matters. To create
    # an expected default behavior, switch to the JUSTFILE dir before searching
    # for the docker-compose file.
    pushd "${JUST_DOCKER_COMPOSE_DIR-"$(dirname "${JUSTFILE}")"}" > /dev/null
      parent_find_files docker-compose.yml docker-compose.yaml
    popd > /dev/null

    docker_compose_files=(${file_matches+"${file_matches[@]}"})
    if [ ${#docker_compose_files[@]} -ne 0 ]; then
      local override
      for override in "$(dirname "${docker_compose_files[0]}")/docker-compose.override.yml" \
                      "$(dirname "${docker_compose_files[0]}")/docker-compose.override.yaml"; do
        if [ -e "${override}" ]; then
          docker_compose_files+=("${override}")
        fi
      done
    fi

    for compose_file in ${docker_compose_files+"${docker_compose_files[@]}"}; do
      docker_compose_args+=(-f "${compose_file}")
    done
  fi

  # project name argument wins
  if [ "${docker_compose_project_name:+set}" != "set" ]; then
    # Then environment variable,
    if [ "${COMPOSE_PROJECT_NAME:+set}" = "set" ]; then
      docker_compose_project_name="${COMPOSE_PROJECT_NAME}"
    elif [ ${#docker_compose_files[@]} -ne 0 ]; then
      docker_compose_project_name="$(basename "$(cd "$(dirname "${docker_compose_files[0]}")"; pwd)")"
    else
      docker_compose_project_name=default
    fi
  fi
}

#****f* docker_functions.bsh/compose_path_separator
# NAME
#   compose_path_separator - Reproduce docker-compose logic for pathsep
# DESCRIPTION
#   docker-compose uses some logic to determine the IFS separator for splitting
#   up the COMPOSE_FILE environment variable. This should return the exact same
#   result
# OUTPUT
#   stdout - IFS string
# USAGE
#   local OLD_IFS="${IFS}"
#   local IFS="$(compose_path_separator)"
#   ...
#   IFS="${OLD_IFS}"
# AUTHOR
#   Andy Neff
#***
function compose_path_separator()
{
  if [ "${COMPOSE_PATH_SEPARATOR:+set}" = "set" ]; then
    echo "${COMPOSE_PATH_SEPARATOR}"
  elif [ "${OS-notwindows}" = "Windows_NT" ]; then
    echo ";"
  else
    echo ":"
  fi
}

#****f* docker_functions.bsh/Docker-compose
# NAME
#   Docker-compose - Helper function to execute (dryrun) the right command
# DESCRIPTION
#   Instead of calling the docker-compose command directly, the Docker-compose
#   command should be called instead (for all dryrun-able activities. Simple
#   commands like ps, etc. don't make as much sense to dryrun, as the reset of
#   the script will never be executed, thus rendering dryrun useless.)
# INPUTS
#   DOCKER_COMPOSE_EXTRA_ARGS - Array of extra arguments inserted after
#                               docker-compose but before the docker subcommand
#   DOCKER_COMPOSE_EXTRA_{subcommand}_ARGS - Array of extra arguments inserted
#                                            right after the docker subcommand
#   DOCKER_COMPOSE_AUTOREMOVE - Automatically add the --rm flag to
#                               docker-compose run commands
#   when using the Docker-compose helper function

#   DRYRUN - Optional variable inserted at the beginning of all docker commands.
#            Useful for setting to "echo" or similar for dryrun mode
#   $1.. - Arguments to be sent to docker-compose command
# OUTPUT
#   Runs docker-compose command
# BUGS
#   Docker-compose should not be exec'd like Docker was. Since fifo buffers are
#   created in common usage of Docker-compose, `exec Docker-compose` would
#   result in fifo buffers being left behind in /tmp
# AUTHOR
#   Andy Neff
#***
function Docker-compose()
{
  local docker_compose_args
  local docker_compose_command
  local docker_compose_command_args
  local docker_compose_files
  local docker_compose_project_name

  parse-docker-compose ${@+"${@}"}

  _Docker-compose
}

function _Docker-compose()
{
  local docker_compose_extra_command_args=()
  local cmd=(${DRYRUN} ${DOCKER_COMPOSE})
  local extra_args_var

  if [ "${docker_compose_command}" = "run" ] && [ "${DOCKER_COMPOSE_AUTOREMOVE-1}" == "1" ]; then
    docker_compose_extra_command_args+=(--rm)
  fi

  #Indirect add DOCKER_COMPOSE_EXTRA_{COMMAND}_ARGS
  extra_args_var=$(tr '[a-z]' '[A-Z]' <<< "${docker_compose_command}")
  extra_args_var="DOCKER_COMPOSE_EXTRA_${extra_args_var}_ARGS[@]"
  docker_compose_extra_command_args+=(${!extra_args_var+"${!extra_args_var}"})

  "${cmd[@]}" \
      ${docker_compose_args+"${docker_compose_args[@]}"} \
      ${DOCKER_COMPOSE_EXTRA_ARGS+"${DOCKER_COMPOSE_EXTRA_ARGS[@]}"} \
      ${docker_compose_command} \
      ${docker_compose_extra_command_args+"${docker_compose_extra_command_args[@]}"} \
      ${docker_compose_command_args+"${docker_compose_command_args[@]}"}
  return $?
}

#****f* docker_functions.bsh/Just-docker-compose
# NAME
#   Just-docker-compose - Docker-compose with advance just features
# INPUTS
#   $1... - Arguments to docker-compose
#   JUST_PROJECT_PREFIX - Typically, the project name that all the variables are
#                         prepended with. EXAMPLE would cover EXAMPLE_VARIABLE
#   [COMPOSE_VERSION] - The docker compose yaml version number is auto
#                       determined by parsing the existing files, and is used in
#                       the auto generated files. In order to bypass this, you
#                       can specify the version number manually using this
#                       variable.
# DESCRIPTION
#   To provide a smoother just experience, advanced features are baked into
#   Just-docker-compose to work with Just and docker_entrypoint.bsh to cover the
#   last mile in getting docker started and setup with a predictable environment
#   user permissions, mounts (and more...)
#
#   Creates a docker override yaml file and extends the current docker-compose
#   configuration.
#
#   See docker_compose_override/generate_docker_compose_override for more
#   information
#
#   Determines which docker compose yaml files to use by mimicking the
#   behavior of docker-compose, which includes querying the COMPOSE_FILE
#   environment variable or trying the default files
# BUGS
#   A temp file is left behind in dryrun mode so that dryrun mode will actually
#   work. As long as the commands echo'd by dryrun are executed, the temp file
#   will be cleaned up, as one of them is rm. So ultimately, this is by design.
#
#   Using this function with windows paths is not currently supported
#
#   You can not use process substitution for the docker-compose.yml file, since
#   bash has to read it before docker-compose reads it. So no:
#   Just-docker-compose -f <(echo "${compose_file}") run test
#   You have to use files
# SEE ALSO
#   docker_compose_override/generate_docker_compose_override
# AUTHOR
#   Andy Neff
#***
function Just-docker-compose()
{
  if [ ! "${JUST_PROJECT_PREFIX:+set}" == "set" ]; then
    echo "You need to define JUST_PROJECT_PREFIX for this to work. Please add"
    echo "JUST_PROJECT_PREFIX to your environment script, typically the project"
    echo "name in caps."
    exit 1
  fi

  local docker_compose_args
  local docker_compose_command
  local docker_compose_command_args
  local docker_compose_files
  local docker_compose_project_name

  local override_file="$(mktemp)"

  parse-docker-compose ${@+"${@}"}

  # 1. Get docker-compose version
  # Auto detect compose version (PURE BASH, WHAT?!)
  if [ "${COMPOSE_VERSION:+set}" != "set" ]; then
    while IFS='' read -r line || [[ -n "${line}" ]]; do
      if [[ $line =~ ^version\ *:\ *[\'\"](.*)[\'\"] ]]; then
        local COMPOSE_VERSION=${BASH_REMATCH[1]}
        break
      fi
    done < "${docker_compose_files[0]}"
  fi

  # 2. Get service name list
  # Get complete list of unique service names
  local service_names=()
  local compose_file
  for compose_file in "${docker_compose_files}"; do
    service_names+=($(docker_compose_service_names ${compose_file}))
  done

  # 3. Unique service name list
  local OLD_IFS="${IFS}"
  local IFS=$'\n'
  service_names=($(awk '!count[$0]++' <<< ${service_names+"${service_names[*]}"}))
  IFS="${OLD_IFS}"

  # 4. Create override file
  generate_docker_compose_override ${JUST_PROJECT_PREFIX} \
      ${service_names+"${service_names[@]}"} > "${override_file}"

  # 5. Add the override file to compose files
  docker_compose_args+=(-f "${override_file}")

  # 6. Call docker compose
  # "Fail later" behavior for set -eu. This should guarantee the override_file
  # is deleted. If this isn't enough, investigate adding cleanup to a trap
  local rv=0
  _Docker-compose || rv=$?
  ${DRYRUN} rm "${override_file}"
  return $rv
}

#****f* docker_functions.bsh/docker_service_running
# NAME
#   docker_service_running - Checks to see if a service is running
# DESCRIPTION
#   Returns the state-status of any containers, using the docker-compose service
#   names.
# INPUTS
#   [$1...] - service names, if none are provided, all are used
#   COMPOSE_FILE - Colon delimited file listing docker-compose files to use
# OUTPUT
#   stdout - State of service running, Up/Exited/Creating/etc...
# RETURN VALUE
#   0 - Service found
#   1 - Service not found
# AUTHOR
#   Andy Neff
#***
function docker_service_running()
{
  ${DOCKER} inspect -f '{{.State.Status}}' \
            $(${DOCKER_COMPOSE} ps -q ${@+"${@}"}) 2>/dev/null
}

#****f* docker_functions.bsh/docker_compose_service_names
# NAME
#   docker_compose_service_names - Get service names from compose yaml file
# INPUTS
#   $1 - docker compose yaml file
# OUTPUT
#   stdout - New line separated list of service names
# AUTHOR
#   Andy Neff
#***
function docker_compose_service_names()
{
           # Skip (d) all lines until services: is matched
  sed -nE '/^services:/b services
           d
           :services
           # Read next line
           n
           # Two space only indent is a service name
           /^  [^ ]*:.*/{
             # Remove leading spaces and :.*
             s|^  ([^ ]*):.*|\1|
             p
             b services
           }
           # As soon as a line not starting with a space is encountered, the
           # service section is over, so (q)uit
           /^[^ ]/q
           b services' "${1}"
}

#****f* docker_functions.bsh/filter_docker_variables
# NAME
#   filter_docker_variables - Helper function to remove variables in a docker
# DESCRIPTION
#   Filters out environment variables $1_*_DOCKER if JUST_FILTER_DOCKER is
#   enabled. Should be called from the entrypoint.
# INPUTS
#   [$1] - The prefix of the variables you want cleared, typically
#          JUST_PROJECT_PREFIX. Default: ${JUST_PROJECT_PREFIX}
#   [JUST_FILTER_DOCKER] - If this is set to 1, and this script is being
#                          executed inside a docker, then ${1}_.*_DOCKER
#                          variables are unset. Default: on
# AUTHOR
#   Andy Neff
#***
function filter_docker_variables()
{
  local temp_var_name
  # This feature was enabled
  if [ "${JUST_FILTER_DOCKER-1}" == "1" ]; then
    for temp_var_name in $(compgen -A variable | \
                           grep "^${1-${JUST_PROJECT_PREFIX}}_.*_DOCKER$"); do
      unset "${temp_var_name}"
    done
  fi
}

#****f* docker_functions/docker_compose_sanitize_project_name
# NAME
#   docker_compose_sanitize_project_name - Make a valid project name
# DESCRIPTION
#   Docker compose will auto generate a project name based off of the directory
#   name. A docker compose project name can only have lowercase letters and
#   numbers. This function will reproduce that same functionality so that you
#   can have that value in bash, with some added benefits (prefix) to truly take
#   control of your docker-compose experience.
# INPUTS
#   $1 - Directory name. Can also be any name really. But directory name is what
#        docker-compose uses to come up with the project name
#   [$2] - Optionally specify a prefix (like a username) to assist in making
#          a (user) specific project name
# EXAMPLE
#   docker_compose_sanitize_project_name 'project/A@1.1_2'
#     projectA112
#
#   docker_compose_sanitize_project_name 'project/A@1.1_2' 'a-user:7'
#     auser7projectA112
#
#   docker_compose_sanitize_project_name '' 'a-user:7'
#     auser7
# AUTHOR
#   Andy Neff
#***
function docker_compose_sanitize_project_name()
{
  awk '{sub(/\/*$/, "", $0)
        n=split($0,arr, /\//)
        a=tolower("'"${2+$2}"'" arr[n])
        gsub(/[^a-z0-9]/,"",a)
        print a}' <<< "${1}"
}
