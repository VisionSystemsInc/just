#!/usr/bin/env false
#Source this script for docker specific helper functions for just or other

: ${JUST_DIR="$(dirname "${BASH_SOURCE[0]}")/"}
source "${JUST_DIR}/mount_tools.bsh"
source "${JUST_DIR}/docker_compose_override"

#****F* just/docker_functions.bsh
# NAME
#   docker_functions.bsh - Set of functions to make using dockers easier
# AUTHOR
#   Andy Neff
#***

#****d* docker_functions.bsh/DOCKER
# NAME
#   DOCKER - Name/path of docker executable
# SYNOPSIS
#   Instead of hard-coding "docker" everywhere, use the variable DOCKER so that
#   when the need comes, it is easier to switch which executable gets called
# AUTHOR
#   Andy Neff
#***
: ${DOCKER=docker}
#****d* docker_functions.bsh/NVIDIA_DOCKER
# NAME
#   NVIDIA_DOCKER - Name/path of nvidia-docker executable
# SYNOPSIS
#   Instead of hard-coding "nvidia-docker" everywhere, use the variable
#   NVIDIA_DOCKER so that when the need comes, it is easier to switch which
#   executable gets called. Default to DOCKER if nvidia-docker executable is not
#   in the path (hash-able)
# AUTHOR
#   Andy Neff
#***
: ${NVIDIA_DOCKER=nvidia-docker}
if ! hash ${NVIDIA_DOCKER} 2> /dev/null; then
  NVIDIA_DOCKER=${DOCKER}
fi


#****d* docker_functions.bsh/is_dir_and_not_exist
# NAME
#   is_dir_and_not_exist - See if the string looks like a non-existing directory
# DESCRIPTION
#   Docker currently creates directories that do not exist when mounting. This
#   has a few bad side effects, such as the directories end up being own by root.
#   In order to work around this "bug", this function identifies if docker will
#   assume a string is a directory/file or an internal mount.
# INPUTS
#   $1 - String to check
# OUTPUT
#   Returns 0 for is a directory, and 1 for not a directory (is an internal
#   mount)
# EXAMPLE
#   is_dir_and_not_exist this_looks_like_a_mount
#   is_dir_and_not_exist ./this_looks/like_a/directory
#   is_dir_and_not_exist /this_also_looks/like_a/directory
#
#   if is_dir_and_not_exist ${my_mount}; then
#     mkdir -p ${my_mount}
#   fi
# AUTHOR
#   Andy Neff
# SEE ALSO
#   docker_functions.bsh/docker_sanitize_volume
#***
function is_dir_and_not_exist()
{
 local dir_name="$1"

 if ( [ "${dir_name:0:1}" == "/" ] || \
      ( (( ${#dir_name} >= 2 )) && [ "${dir_name:0:2}" == "./" ] ) ) && \
    [ ! -d "${dir_name}" ] && [ ! -e "${dir_name}" ]; then
    return 0 #TRUE!
 fi
 return 1 #False :(
}


#****f* docker_functions.bsh/container_get_label
# NAME
#   container_get_label - Get a label value from a docker container
# INPUTS
#   $1 - Container name
#   $2 - Label name
# OUTPUT
#   stdout - Prints out the label value (and evaluates environment variables)
#   Return 1 if label is blank (possibly not set), 0 for label found
# NOTES
#   Requires perl be installed
# AUTHOR
#   Andy Neff
#***
function container_get_label()
{ # All labels go through a perl filter that evaluate %name% using exported
  # environment variables. This won't work on unexported variables
  local value=$(docker inspect -f "{{index .Config.Labels \"$2\"}}" $1)
  if [ "${value}" == "" ]; then
    return 1
  fi

  echo "${value}" | perl -wpe 's#\%?(\w+)\%# $ENV{$1} // $& #ge;'

  return 0
}


#****f* docker_functions.bsh/container_has_label
# NAME
#   container_has_label - Check to see if a container contains a certain label
# SYNOPSIS
#   docker_functions.bsh/container_get_label can not tell whether a container
#   has a label or not when the label is blank. The go template filter does not
#   differentiate. This will verify that a blank label is set or unset.
# INPUTS
#   $1 - Container name
#   $2 - Label name
# OUTPUT
#   Return 1 for label is unset, 0 for label is set
# NOTES
#   Requires jq be installed
# AUTHOR
#   Andy Neff
#***
function container_has_label()
{
  if [ "$(docker inspect -f '{{json .Config.Labels }}' $1 | \
          jq .\[\"$2\"\])" == "null" ]; then
    return 1
  else
    return 0
  fi
}


#****f* docker_functions.bsh/docker_sanitize_volume
# NAME
#   docker_sanitize_volume - Convenient wrapper to deal with the MINGW screw ups
# DESCRIPTION
#   A number of things can go wrong with something as simple as mounting a
#   directory. If the directory doesn't exist, root will end up owning the
#   directory (which is often not desired). Also, on MINGW Linux/Windows path
#   expansion ends up being an error to docker on windows. So this function will
#   take care of both of these problems in an OS agnostic way.
# INPUTS
#   $1 - The host directory/volume name
#   [$2] - The docker directory (optional. If omitted, copies host directory)
# OUTPUT
#   stdout - The argument that should go with the -v to docker for mounting
# BUGS
#   The docker directory is not optional if the host mount is a volume
# AUTHOR
#   Andy Neff
#***
function docker_sanitize_volume()
{
 if (( $# < 2 )); then
   set -- "$1" "$1"
 fi

 # Create the directory before docker, or else it will be owned by ROOT! :(
 # Assume it's a directory because well... docker would too
 if is_dir_and_not_exist "$1"; then #if not a file or dir
   mkdir -p "$1" #make the dir
   chmod 777 "$1" #Blow open permissions
 fi

 if [ "${OS-notwindows}" == "Windows_NT" ]; then
   if command -v cygpath &> /dev/null ; then
     echo "$(cygpath -w "$1"):/$2"
     #Bash 4 in mingw64 includes cygpath for some reason
     #Cygpath converts / -> \
     #^/{single letter} -> {single letter}:\
     #^/{single letter}/ -> {single letter}:\\ #bug?
     #else ^/ -> {git_directory}
   else
     echo "$1:/$2"
   fi
 else
   echo "$1:$2"
 fi
}

#****f* docker/docker-compose-volumes
# NAME
#   docker-compose-volumes - Get volume flags from docker-compose config
# PURPOSE
#   Reformats the output from docker-compose config to an array with -v flags
#   for use in passing to another docker or docker-compose run command.
# INPUTS
#   $1 - name of service of interest
#   [$2] - prefix to volume names
# OUTPUT
#   DOCKER_VOLUME_FLAGS - Array of the docker flags, including necessary -v's
# EXAMPLE
#  docker-compose.yml
#    version: "3.2"
#    services:
#      nb:
#        image : blah
#        volumes:
#          - /tmp:/mnt
#          - test:/opt
#    volumes:
#      test:
#
#  docker-compose-volumes nb test_prefix_ < <(docker-compose config)
#  # Or
#  # docker-compose-volumes nb <<< "$(docker-compose config)"
#
#  declare -p DOCKER_VOLUME_FLAGS
#  > declare -a DOCKER_VOLUME_FLAGS='([0]="-v" [1]="/tmp:/mnt:rw" [2]="-v"
#                                     [3]="test_prefix_test:/opt")'
# NOTES
#   Useful for working around docker/compose#4728
# AUTHOR
#   Andy Neff
#***
function docker-compose-volumes()
{
  local OLD_IFS="${IFS}"
  local PREFIX="${2-}"
  IFS=$'\n'
  DOCKER_VOLUME_FLAGS=(\
    $(sed -nE '/^services:$/b services
               d
               :services
               n
               # Search for the service entry
               /^  '"${1}"':$/b found
               /^ /b services
               d
               :found
               # Clear pattern buffer and read next line
               n
               # Read volumes: found
               /^    volumes:/b volumes
               # Search all of the service entry
               /^    /b found
               # Volumes were not found, give up
               d
               :volumes
               # Read in a new line
               n
               # Match this new line for an indented(4) list
               /^    -/{
                 s|^    - ([^./])|    - '"${PREFIX}"'\1|
                 # Add these lines to the hold buffer
                 H
                 # Repeat
                 b volumes
               }
               # Switch the hold and pattern buffer
               x
               # Format indented list to look like docker flags
            '$'s|\\n    - |\\\n-v\\\n|g''
               #s|^\n|| # Remove the first blank line - Not needed with array magic
               # Print out that pretty pattern!
               p'))
  IFS="${OLD_IFS}"
}

#****f* docker_functions.bsh/Exec-Nvidia-Docker
# NAME
#   Exec-Nvidia-Docker - Version of Docker for Nvidia and exec's
# AUTHOR
#   Andy Neff
#***
function Exec-Nvidia-Docker(){ DOCKER_EXEC=1 Nvidia-Docker "${@}";}
#****f* docker_functions.bsh/Nvidia-Docker
# NAME
#   Nvidia-Docker - Version of Docker for Nvidia
# AUTHOR
#   Andy Neff
#***
function Nvidia-Docker(){ DOCKER="${NVIDIA_DOCKER}" Docker "${@}";}
#****f* docker_functions.bsh/Exec-Docker
# NAME
#   Exec-Docker - Version of Docker that exec's command rather than call
# AUTHOR
#   Andy Neff
#***
function Exec-Docker(){ DOCKER_EXEC=1 Docker "${@}";}
#****f* docker_functions.bsh/Docker
# NAME
#   Docker - Helper function to execute the right docker command, or just dryrun
# DESCRIPTION
#   Instead of calling the docker command directly, the Docker command should be
#   called instead (for all dryrun-able activities. Simple commands like
#   inspect, ps, etc. don't make as much sense to dryrun, as the reset of the
#   script will never be executed, thus rendering dryrun useless.)
# INPUTS
#   DRYRUN - Optional variable inserted at the beginning of all docker commands.
#            Useful for setting to "echo" or similar for dryrun mode
#   $1.. - Arguments to be sent to docker command
# OUTPUT
#   Runs docker command
# AUTHOR
#   Andy Neff
#***
function Docker()
{
  local cmd

  cmd=(${DRYRUN} "${DOCKER}")

  if [ "$1" == "run" ]; then
    cmd+=($1 ${DOCKER_RUN_ARGS+"${DOCKER_RUN_ARGS[@]}"})
    shift 1
  fi

  if [ "${DOCKER_EXEC-}" == "" ] || [ "${DRYRUN}" != "" ]; then
    "${cmd[0]}" "${cmd[@]:1}" "${@}"
  else
    exec "${cmd[@]}" "${@}"
  fi
}

### docker-compose ###

#****d* docker_functions.bsh/DOCKER_COMPOSE
# NAME
#   DOCKER_COMPOSE - Name/path of docker-compose executable
# SYNOPSIS
#   Instead of hard-coding "docker-compose" everywhere, use the variable
#   DOCKER_COMPOSE so that when the need comes, it is easier to switch which
#   executable gets called
# AUTHOR
#   Andy Neff
#***
: ${DOCKER_COMPOSE=docker-compose}
#****d* docker_functions.bsh/DOCKER_COMPOSE_AUTOREMOVE
# NAME
#   DOCKER_COMPOSE_AUTOREMOVE - Add --rm to docker-compose run commands
# SYNOPSIS
#   Flag to to automatically add the --rm flag to docker-compose run commands
#   when using the Docker-compose helper function
# AUTHOR
#   Andy Neff
#***
: ${DOCKER_COMPOSE_AUTOREMOVE=1}

#****f* docker_functions.bsh/Docker-compose
# NAME
#   Docker-compose - Helper function to execute (dryrun) the right command
# DESCRIPTION
#   Instead of calling the docker-compose command directly, the Docker-compose
#   command should be called instead (for all dryrun-able activities. Simple
#   commands like ps, etc. don't make as much sense to dryrun, as the reset of
#   the script will never be executed, thus rendering dryrun useless.)
# INPUTS
#   DOCKER_COMPOSE_EXTRA_ARGS - Array of arguments to be added to docker-compose
#                               (before the command)
#   DOCKER_COMPOSE_EXTRA_COMMAND_ARGS - Array of arguments to be added to
#                                       docker-compose (after the command)
#   DOCKER_COMPOSE_EXTRA_RUN_ARGS - Array of arguments to be added to
#                                   docker-compose (after the run command only)
#   DOCKER_COMPOSE_AUTOREMOVE - See docker_functions.bsh/DOCKER_COMPOSE_AUTOREMOVE
#   DRYRUN - Optional variable inserted at the beginning of all docker commands.
#            Useful for setting to "echo" or similar for dryrun mode
#   $1.. - Arguments to be sent to docker command
# OUTPUT
#   Runs docker command
# BUGS
#   Docker-compose should not be exec'd like Docker was. Since fifo buffers are
#   created in common usage of Docker-compose, `exec Docker-compose` would
#   result in fifo buffers being left behind in /tmp
# AUTHOR
#   Andy Neff
#***
function Docker-compose()
{
  local docker_compose_args=()
  local docker_compose_auto_command_args=()
  local docker_compose_command

  local cmd=(${DRYRUN} ${DOCKER_COMPOSE})

  while (( $# )); do
    case "$1" in
      run)
        docker_compose_command="$1"
        shift 1
        if [ "${DOCKER_COMPOSE_AUTOREMOVE}" == "1" ]; then
          docker_compose_auto_command_args+=(--rm)
        fi
        docker_compose_auto_command_args+=(${DOCKER_COMPOSE_EXTRA_RUN_ARGS+"${DOCKER_COMPOSE_EXTRA_RUN_ARGS[@]}"})
        break
        ;;
      # Insert other commands here for command specific EXTRA_<command>_ARGS
      -f*|-p*|-H*)
        if [ "${#1}" == 2 ]; then
          docker_compose_args+=("$1" "$2")
          shift 2
        else
          docker_compose_args+=("$1")
          shift 1
        fi
        ;;
      --file=*|--project-name=*|--host=*|\
      --tlscacert=*|--tlscert=*|--tlskey=*|--project-directory=*|\
      -v|--verbose|--tls|--skip-hostname-check|--tlsverify)
        docker_compose_args+=("$1")
        shift 1
        ;;
      --file|--project-name|--host|\
      --tlscacert|--tlscert|--tlskey|--project-directory)
        docker_compose_args+=("$1" "$2")
        shift 2
        ;;
      *)
        docker_compose_command="$1"
        shift 1
        break
        ;;
    esac
  done
  "${cmd[@]}" \
      ${DOCKER_COMPOSE_EXTRA_ARGS+"${DOCKER_COMPOSE_EXTRA_ARGS[@]}"} \
      ${docker_compose_args+"${docker_compose_args[@]}"} \
      ${docker_compose_command} \
      ${docker_compose_auto_command_args+"${docker_compose_auto_command_args[@]}"} \
      ${DOCKER_COMPOSE_EXTRA_COMMAND_ARGS+"${DOCKER_COMPOSE_EXTRA_COMMAND_ARGS[@]}"} \
      ${@+"${@}"}
  return $?
}

#****f* docker_functions.bsh/Just-docker-compose
# NAME
#   Just-docker-compose - Docker-compose with advance just features
# INPUTS
#   $1... - Arguments to docker-compose
#   JUST_PROJECT_PREFIX - Typically, the project name that all the variables are
#                         prepended with. EXAMPLE would cover EXAMPLE_VARIABLE
#   [COMPOSE_VERSION] - The docker compose yaml version number is auto
#                       determined by parsing the existing files, and is used in
#                       the auto generated files. In order to bypass this, you
#                       can specify the version number manually using this
#                       variable.
# DESCRIPTION
#   To provide a smoother just experience, advanced features are baked into
#   Just-docker-compose to work with Just and docker_entrypoint.bsh to cover the
#   last mile in getting docker started and setup with a predictable environment
#   user permissions, mounts (and more...)
#
#   Creates a docker override yaml file and extends the current docker-compose
#   configuration.
#
#   See docker_compose_override/generate_docker_compose_override for more
#   information
#
#   Determines which docker compose yaml files to use by mimicking the
#   behavior of docker-compose, which includes querying the COMPOSE_FILE
#   environment variable or trying the default files
# BUGS
#   A temp file is left behind in dryrun mode so that dryrun mode will actually
#   work. As long as the commands echo'd by dryrun are executed, the temp file
#    will be cleaned up, as one of them is rm. So ultimately, this is by design.
# SEE ALSO
#   docker_compose_override/generate_docker_compose_override
# AUTHOR
#   Andy Neff
#***
function Just-docker-compose()
{
  if [ ! "${JUST_PROJECT_PREFIX+set}" == "set" ]; then
    echo "You need to define JUST_PROJECT_PREFIX for this to work. Please add"
    echo "JUST_PROJECT_PREFIX to your environment script, typically the project"
    echo "name in caps."
    exit 1
  fi

  local override_file="$(mktemp)"
  local compose_file_override

  # Add the override
  if [ "${COMPOSE_FILE+set}" == "set" ]; then
    compose_file_override="${COMPOSE_FILE}"
  else
    local f
    # Mimic docker-compose's default behavior
    compose_file_override=
    # The ./ is to fool MINGW64's path conversion[1]; On Windows, the ; path
    # separator is expected; however, if used, MINGW64 does not attempt path
    # conversion. Instead, use :, as expected by MINGW64, and specify all paths
    # using POSIX style (e.g., ./docker-compose.yml instead of
    # docker-compose.yml).
    # [1] http://www.mingw.org/wiki/Posix_path_conversion
    for f in ./docker-compose.yml ./docker-compose.yaml \
             ./docker-compose.override.yml ./docker-compose.override.yaml; do
      [ -e "${f}" ] && compose_file_override+="${f}"
    done
  fi

  # Auto detect compose version (PURE BASH, WHAT?!)
  if [ "${COMPOSE_VERSION+set}" != "set" ]; then
    while IFS='' read -r line || [[ -n "${line}" ]]; do
      if [[ $line =~ ^version\ *:\ *[\'\"](.*)[\'\"] ]]; then
        local COMPOSE_VERSION=${BASH_REMATCH[1]}
        break
      fi
    done < "${compose_file_override%%:*}"
  fi

  # Get complete list of unique service names
  local service_names=()
  local OLD_IFS="${IFS}"
  local IFS=":"
  local compose_files=(${compose_file_override})
  IFS="${OLD_IFS}"
  local compose_file
  for compose_file in "${compose_files}"; do
    service_names+=($(docker_compose_service_names ${compose_file}))
  done
  # Unique it
  IFS=$'\n'
  service_names=($(awk '!count[$0]++' <<< ${service_names+"${service_names[*]}"}))
  IFS="${OLD_IFS}"

  generate_docker_compose_override ${JUST_PROJECT_PREFIX} \
      ${service_names+"${service_names[@]}"} > "${override_file}"

  # Add the override file to compose files
  compose_file_override+=":${override_file}"

  # "Fail later" behavior for set -eu. This should guarantee the override_file
  # is deleted. If this isn't enough, investigate adding cleanup to a trap
  local rv=0
  if [ "${DRYRUN-}" != "" ]; then
    echo -n "env COMPOSE_FILE=\"${compose_file_override}\" "
  fi
  COMPOSE_FILE="${compose_file_override}" Docker-compose ${@+"${@}"} || rv=$?
  ${DRYRUN} rm "${override_file}"
  return $rv
}

#****f* docker_functions.bsh/docker_service_running
# NAME
#   docker_service_running - Checks to see if a service is running
# DESCRIPTION
#   Returns the state-status of any containers, using the docker-compose service
#   names.
# INPUTS
#   [$1...] - service names, if none are provided, all are used
#   COMPOSE_FILE - Colon delimited file listing docker-compose files to use
# OUTPUT
#   stdout - State of service running, Up/Exited/Creating/etc...
# RETURN VALUE
#   0 - Service found
#   1 - Service not found
# AUTHOR
#   Andy Neff
#***
function docker_service_running()
{
  ${DOCKER} inspect -f '{{.State.Status}}' \
            $(${DOCKER_COMPOSE} ps -q ${@+"${@}"}) 2>/dev/null
}

#****f* docker_functions.bsh/docker_compose_service_names
# NAME
#   docker_compose_service_names - Get service names from compose yaml file
# INPUTS
#   $1 - docker compose yaml file
# OUTPUT
#   stdout - New line separated list of service names
# AUTHOR
#   Andy Neff
#***
function docker_compose_service_names()
{
           # Skip (d) all lines until services: is matched
  sed -nE '/^services:/b services
           d
           :services
           # Read next line
           n
           # Two space only indent is a service name
           /^  [^ ]*:.*/{
             # Remove leading spaces and :.*
             s|^  ([^ ]*):.*|\1|
             p
             b services
           }
           # As soon as a line not starting with a space is encountered, the
           # service section is over, so (q)uit
           /^[^ ]/q
           b services' "${1}"
}

#****f* docker_functions.bsh/filter_docker_variables
# NAME
#   filter_docker_variables - Helper function to remove variables in a docker
# DESCRIPTION
#   Filters out environment variables $1_*_DOCKER if JUST_FILTER_DOCKER is
#   enabled
# INPUTS
#   [$1] - The prefix of the variables you want cleared, typically
#          JUST_PROJECT_PREFIX. Default: ${JUST_PROJECT_PREFIX}
#   [JUST_FILTER_DOCKER] - If this is set to 1, and this script is being
#                          executed inside a docker, then ${1}_.*_DOCKER
#                          variables are unset. Default: on
# AUTHOR
#   Andy Neff
#***
function filter_docker_variables()
{
  local temp_var_name
  # This feature was enabled
  if [ "${JUST_FILTER_DOCKER-1}" == "1" ]; then
    for temp_var_name in $(compgen -A variable | \
                           grep "^${1-${JUST_PROJECT_PREFIX}}_.*_DOCKER$"); do
      unset "${temp_var_name}"
    done
  fi
}

#****f* docker_functions/docker_compose_sanitize_project_name
# NAME
#   docker_compose_sanitize_project_name - Make a valid project name
# DESCRIPTION
#   Docker compose will auto generate a project name based off of the directory
#   name. A docker compose project name can only have lowercase letters and
#   numbers. This function will reproduce that same functionality so that you
#   can have that value in bash, with some added benefits (prefix) to truly take
#   control of your docker-compose experience.
# INPUTS
#   $1 - Directory name. Can also be any name really. But directory name is what
#        docker-compose uses to come up with the project name
#   [$2] - Optionally specify a prefix (like a username) to assist in making
#          a (user) specific project name
# EXAMPLE
#   docker_compose_sanitize_project_name 'project/A@1.1_2'
#     projectA112
#
#   docker_compose_sanitize_project_name 'project/A@1.1_2' 'a-user:7'
#     auser7projectA112
#
#   docker_compose_sanitize_project_name '' 'a-user:7'
#     auser7
# AUTHOR
#   Andy Neff
#***
function docker_compose_sanitize_project_name()
{
  awk '{sub(/\/*$/, "", $0)
        n=split($0,arr, /\//)
        a=tolower("'"${2+$2}"'" arr[n])
        gsub(/[^a-z0-9]/,"",a)
        print a}' <<< "${1}"
}
