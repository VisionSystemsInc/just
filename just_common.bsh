#!/usr/bin/env false
#This file should be sourced, NOT run

#****d* just/JUST_VERSION
# NAME
#   JUST_VERSION - Version number of just
# DESCRIPTION
#   If the version number from the last time the just setup script was sourced
#   and just do not match, a warning message will appear
# SEE ALSO
#   just/JUST_SETUP_SCRIPT
# AUTHOR
#   Andy Neff
#***
_last_just_version=${JUST_VERSION-}
export JUST_VERSION=0.0.4
   # If last just version was set and different
if [ "${_last_just_version}" != "" ] && \
   [ "${_last_just_version}" != ${JUST_VERSION} ]; then
  echo "WARNING: The version of just (${JUST_VERSION}) appears to have changed" >&2
  echo "since last time (${_last_just_version})" >&2
  echo "You may want to source ${JUST_SETUP_SCRIPT-your setup script} again" >&2
  echo >&2
fi
unset _last_just_version

#****d* just/JUST_SETUP_SCRIPT
# NAME
#   JUST_SETUP_SCRIPT - Name of the just setup script
# DESCRIPTION
#   When writing a setup script (typically called setup.env), JUST_SETUP_SCRIPT
#   can optionally be set to the name of the script that will be used in
#   messages such as the version check.
# EXAMPLE
#   Usually developers will source a simple script to setup just. This primarily
#   includes adding just to the path and setting up tab complete:
#
#     export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#     source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/external/vsi_common/env.bsh"
#
#   This might also include adding plugins for tab-complete
#
#     JUST_HELP_FILES=("${JUST_DIR}"/just_git_functions.bsh)
#
#   This is also a convenient place to slip in git hooks
#
#     #Create post-checkout hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-checkout"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         if [ "\$1" != "\$2" ]; then
#           echo
#           echo "Don't forget to update your environment with the command: just sync"
#         fi
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#
#     #Create post-merge hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-merge"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         echo
#         echo "Don't forget to update your environment with the command: just sync"
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#     unset _just_temp_filename
# AUTHOR
#   Andy Neff
#***

#****if* just/_just_find_justfile
# NAME
#   _just_find_justfile - Find the Justfile
# DESCRIPTION
#   Searches for the Justfile to load. It starts by checking the current
#   directory, and goes up. Just like git searches for a .git directory
# INPUTS
#   $1... - The name of the files being searched for, typically: Justfile
# RETURN VALUE
#   echoes out the filename if found, else nothing
# AUTHOR
#   Andy Neff
#***
_just_find_justfile()
{
  # local just_tmp_last_node=
  # local just_tmp_stat_command
  # local i
  #speed improvement: if it's right there, echo it out right away
  if [ -f "${1}" ]; then
    echo "${PWD}/${1}"
    return
  fi
  #else search for the file

  \pushd . > /dev/null
  while : ; do
    if [ -f "${1}" ]; then
      \echo "$(\cd "$(\dirname "${1}")"; \pwd)/$(\basename "${1}")"
      break
    fi

    if [ "${PWD}" == "/" ]; then
      break
    fi

    cd ..
  done
  \popd > /dev/null

  #This may be all be unnecessary. Use the simple way until bug reports rain in

  # # First try the obvious. cd .. until you hit /. This is fast yet susceptible
  # # to a lot of corner conditions. So only try like 10 times

  # for ((i=0; i<10; i++)); do
  #   if [ -f "${1}" ]; then
  #     \echo "$(\cd "$(\dirname "${1}")"; \pwd)/$(\basename "${1}")"
  #     \popd > /dev/null
  #     return
  #   fi
  #   if [ "${PWD}" == "/" ]; then
  #     break
  #   fi
  # done

  # # Second try a much more robust method, that should not get an an infinite
  # # loop

  # # Get OS independent device_id:inode string
  # if [ "$(\uname)" == "Darwin" ]; then
  #   just_tmp_stat_command="stat -f %d:%i ."
  # else
  #   just_tmp_stat_command="stat -c %d:%i ."
  # fi

  # while [ "${just_tmp_last_node}" != "$(\eval ${just_tmp_stat_command})" ]; do
  #   if [ -f "${1}" ]; then
  #     \echo "$(\cd "$(\dirname "${1}")"; \pwd)/$(\basename "${1}")"
  #     break
  #   fi
  #   just_tmp_last_node=$(\eval ${just_tmp_stat_command})
  #   \cd ..
  # done
  # \popd > /dev/null
}

#****f* just/_just_commands_from_file
# NAME
#   _just_commands_from_file - Parses Justfile for help comments on targets
# SYNOPSIS
#   Look for all case statements with a comment at the end. It will also parse
#   commented case statements that exist for the purpose of populating the help
# INPUTS
#   $1 - Filename of Justfile to be parsed
# SEE ALSO
#   JUST_HELP_SEPARATOR, just/help
# AUTHOR
#   Andy Neff
#***
function _just_commands_from_file()
{
           # Segment into "command JUST_HELP_SEPARATOR comment"
  \sed -nE ':combine
            # These next 5 lines combine lines ending in \ and remove leading spaces on next line
            /\\$/{
              # Read and append next line
              N
              # If the pattern buffer matches the case pattern, ends in a
              # \ and the comment continues on the next line, then combine
              /^ *#? *[ _0-9|a-zA-Z{}-]*\) *#.*\\\n *#/{
                # Combine the two lines, removing the extra #, replacing it
                # with a single space
                s| *\\\n *# *| |
                t combine
              }
              s|\\\n *||''
              t combine
            }
            s|^ *#? *([ _0-9|a-zA-Z{}-]*)\) *# *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
            # If there is a match, process it
            t process
            # Else do not even print it. This replaces a grep
            b noprint
            :process
            # Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
            s/\|(.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2'$'\\\n''\1/
            # Continue processing until no matches
            t process
            p
            :noprint' $1
}

#****f* just/_just_subcommands_from_array
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#   _just_subcommands_from_array <<< "${parsed_help_a[*]}"
#***
function _just_subcommands_from_array()
{
  \sed -nE 's|^(_?[a-zA-Z0-9\-]+)_.*|\1|p'
}

#****f* just/_just_subtargets_from_array
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#
#   _just_subtargets_from_array ${TARGET} "${parsed_help_a[@]}"
# INPUTS
#   $1 - subcommand name
#   $2..N - help_lines
# RETURN VALUE
#   just_subtargets - Adds to array
# AUTHOR
#   Andy Neff
#***
function _just_subtargets_from_array()
{
  local help_line
  local subcommand="${1}"
  shift 1

  for help_line in ${@+"${@}"}; do
    if [[ ${help_line} =~ ^${subcommand}_.* ]]; then
      help_line=${help_line%% *}
      just_subtargets+=(${help_line#*_})
    fi
  done
}

#****f* just/_just_parse_helps
# NAME
#   _just_parse_helps - Parse help information out of Just files
# INPUT
#   $1... - List of Just files, including plugins
# OUTPUT
#   parsed_help_a - Array of help lines: "target ${JUST_HELP_SEPARATOR} message"
# AUTHOR
#   Andy Neff
#***
function _just_parse_helps()
{
  local filename
  local IFS=$'\n'
  local i
  local target
  local target_array
  parsed_help_a=()

  for filename in ${@+"${@}"}; do
    parsed_help_a+=($(_just_commands_from_file "${filename}"))
  done

  # Target expansion magic
  for i in "${!parsed_help_a[@]}"; do
    if [[ ${parsed_help_a[$i]} =~ (^.*_)\{(.*)\}(\ ${JUST_HELP_SEPARATOR}\ .*) ]]; then
      unset parsed_help_a[$i]
      target_array="${BASH_REMATCH[2]}[@]"
      target_array=(${!target_array+"${!target_array}"})
      for target in "${target_array[@]}"; do
        parsed_help_a+=("${BASH_REMATCH[1]}${target}${BASH_REMATCH[3]} ${target}")
      done
    fi
  done
}

#****f* just_plugins/_just_get_plugins()
# NAME
#   _just_get_plugins()
# INPUTS
#   [$1] - Default directory to look for JUST_PLUGIN_FILE in
#   [JUST_PLUGIN_FILE] - Optional override the name of the just plugins file.
#                        Default: .justplugins
# OUTPUT
#   JUST_PLUGINS - (Possibly empty) array of plugins filenames
# NOTES
#   _just_get_plugins adds to JUST_PLUGINS if it already exists. If you want to
#   replace JUST_PLUGINS, unset JUST_PLUGINS before calling _just_get_plugins.
# SEE ALSO
#   just/just_plugins, just_plugins/.justplugins
# AUTHOR
#   Andy Neff
#***
function _just_get_plugins()
{
  local line
  local JUST_PLUGIN_FILE=${JUST_PLUGIN_FILE:-.justplugins}
  local base_dir=${1-.}

  # Set JUST_PLUGINS to an empty array if it doesn't exist already
  if ! \declare -p JUST_PLUGINS &>/dev/null; then
    JUST_PLUGINS=()
  fi

  # Prepend the directory if it doesn't exist
  if [ ! -f "${JUST_PLUGIN_FILE}" ]; then
    JUST_PLUGIN_FILE="${1}/${JUST_PLUGIN_FILE}"
  fi

  # Make base_dir absolute
  if [ "${base_dir:0:1}" != "/" ]; then
    base_dir="$(cd "${base_dir}"; pwd)"
  fi

  # Read in the plugin file
  if [ -f "${JUST_PLUGIN_FILE}" ]; then
    while IFS='' \read -r line; do
      # Skip blank lines
      if [[ ${line} =~ ^[[:blank:]]*$ ]]; then
        continue
      fi
      # Skip comments
      if  [[ ${line} =~ ^[[:blank:]]*# ]]; then
        continue
      fi

      if [ "${line:0:1}" != "/" ]; then
        line="${base_dir}/${line}"
      fi

      JUST_PLUGINS+=("${line}")
    done < "${JUST_PLUGIN_FILE}"
  fi
}
