#!/usr/bin/env bash

: ${JUST_DIR="$(dirname "${BASH_SOURCE[0]}")/"}
source "${JUST_DIR}/mount_tools.bsh"

#****F* just/docker_compose_override
# NAME
#   docker_compose_override - Generate docker compose override file
# USAGE
#   Can be called or sourced for finer control
# SEE ALSO
#   docker_compose_override.bsh/generate_docker_compose_override
# AUTHOR
#   Andy Neff
#***

#****fI* docker_compose_override.bsh/_docker_compose_override_var_sub
# INPUTS
#   1 - String of variable name, such as '${var}'.
# OUTPUT
#   stdout - var
# USAGE
#   Assumes the string is a variable expression, so the first letter is assumed
#   to be a $, and is not checked
# EXAMPLE
#   indirect=$(_docker_compose_override_var_sub '${var}')
#   indirect=$(_docker_compose_override_var_sub '$var')
# NOTES
#   Obsolete
# AUTHOR
#   Andy Neff
#***
function _docker_compose_override_var_sub()
{
  # support ${var} notation
  if [ "${1:1:1}" == "{" ]; then
    echo ${1:2:${#1}-3}
  else #support $var notation
    echo ${1:1:${#1}-1}
  fi
}

#****fI* docker_compose_override.bsh/_env_echo
# NAME
#   _env_echo - Helper function for echoing environment variables
# INPUTS
#   * - arguments to echo
# OUTPUT
#   stdout - echo
# USAGE
#   The environment: should only be added once, and can only be added if there
#   is at least one environment variable be set. In case there are none, this
#   simple helper should be used.
# AUTHOR
#   Andy Neff
#***
function _env_echo()
{
  if [ "${new_environment-1}" == "1" ]; then
    echo "    environment:"
    new_environment=0
  fi
  echo ${@+"${@}"}
}

#****f* docker_compose_override.bsh/generate_docker_compose_override
# NAME
#   generate_docker_compose_override - Creates override yaml for just features
# INPUTS
#   $1 - Prefix used in many of the just features, such as ${1}_.*_DOCKER/HOST
#        variables, etc...
#   $2... - List of services to process (see docker_compose_service_names)
#   [COMPOSE_VERSION] - Docker compose version used. Default: 3.2
#   [JUST_DISABLE_ENVIRONMENT_SWAP] - Optionally disables the transparent
#                                     variable swap feature. Default: 0
#   [EXPORT_DOCKER] - Optionally, also adds the {1}_.*_DOCKER version of the
#                     variable (as is) when using the transparent environment
#                     variable swap feature. Default: 0
#   [MOUNT_PREFIX] - Some mounted file systems will not allow subdirectories to
#                    be mounted by root, such as nfs with squash root turned on.
#                    In this case, generate_docker_compose_override will mount
#                    the base mount point in a side location, and symlink the
#                    subdirectory in where it was supposed to be mounted. This
#                    may be slightly less than ideal, but this is the best that
#                    can be done with these file systems. The MOUNT_PREFIX is
#                    the location where these mount points are mounted. These
#                    mount points are not intended to be used by the apps
#                    running in the container. Default: /host_mnt
# OUTPUT
#   stdout - docker-compose yaml files
# DESCIRPTION
#   Create a docker override yaml file and extend the current docker-compose
#   configuration with:
#   - Volume features:
#     - Volumes can be added to the services listed in $2...
#       - Volumes listed in ${1}_VOLUMES are added to every service
#       - Volumes listed in ${1}_<upper(service_name)>_VOLUMES
#         are added just to that service.
#       - NOTE: If the yaml file uses anchors, this will not be reflected in
#         this auto generated file. You will have to set the value of
#         ${1}_<upper(other_service_name)>_VOLUMES as well
#   - Environment features:
#     - For volumes that couldn't be mounted in their expected locations (mostly
#       due to nfs limitations), the variable JUST_DOCKER_ENTRYPOINT_LINKS is
#       set to a colon delimited string (used by
#       docker_entrypoints.bsh/docker_link_mounts).
#     - Environment variables ${1}_.*_HOST are added to the docker environment
#       exactly as is.
#     - Transparently swap environment variables as they are added to the
#       docker environment (default):
#       - For every environment variable, ${1}_.*_DOCKER, and optionally its
#         corresponding un-suffix'ed version ${1}_.*
#         - ${1}_.* variable is copied as ${1}_.*_HOST
#         - ${1}_.*_DOCKER variable is copied as ${1}_.*
#         - VIP_FOO=/opt/foo is copied to VIP_FOO_HOST=/opt/foo and
#           VIP_FOO_DOCKER=/foo is copied to VIP_FOO=/foo
#       - This is a transparency feature. Only _DOCKER variables should use the
#         _DOCKER suffix.
#     - The transparency swap feature can be disabled by setting
#       JUST_DISABLE_ENVIRONMENT_SWAP=1. In which case:
#       - For every environment variable ${1}_.*_DOCKER
#         - ${1}_.*_DOCKER is copied exactly as is
#         - ${1}_.* is copied exactly as is if it exists
# NOTES
#   There is no way to use the _VOLUMES features from the CLI, as arrays cannot
#   be exported
# SEE ALSO
#   docker_entrypoints.bsh/docker_link_mounts
#***
function generate_docker_compose_override()
{
  local volumes_name
  local volume
  local volumes
  local indirect
  local volumes_name_all
  local indirect_all
  local host_mount_point
  local i
  local volume_host
  local volume_docker
  local volume_flags
  local just_docker_entrypoint_links
  local new_environment

  local project_prefix=$1
  shift 1

  local services_name=(${@+"${@}"})
  local services_upper=($(tr '[a-z][:punct:]' '[A-Z]_' <<< ${services_name[@]}))

  # Save old IFS
  local OLD_IFS="${IFS}"
  local IFS="${IFS}"

  echo "version: '${COMPOSE_VERSION-3.2}'"
  echo "services:"
  for i in "${!services_name[@]}"; do
    echo "  ${services_name[$i]}:"

    # Clear list for this service
    just_docker_entrypoint_links=()
    volumes=()

    # Indirect fun
    volumes_name="${project_prefix}_${services_upper[$i]}_VOLUMES"
    indirect="${volumes_name}[@]"
    volumes_name_all="${project_prefix}_VOLUMES"
    indirect_all="${volumes_name_all}[@]"

    # Dynamically add volumes
    for volume in ${!volumes_name_all+"${!indirect_all}"} ${!volumes_name+"${!indirect}"}; do
      docker_parse_volume_string "$volume"


      # If it doesn't exist, attempt to make it as this user. Better than root
      docker_premkdir "${volume_host}"

      # If the volume is a path, get the real path
      if [[ ${volume_host:0:1} =~ [./] ]]; then
        volume_host=$(real_path "${volume_host}")
      fi

      # Check to see that the volume is not a docker volume
      if [ "${volume_host:0:1}" = "/" ]; then
        # If the mount point is nfs AND it isn't already the same as the mount
        if host_mount_point="$(mount_point "${volume_host}" nfs nfs3 nfs4)"; then
          # When I tackle #19, I may add something like
          # if [ "${host_mount_point}" != "${volume_host}" ]; then
          #   just_docker_entrypoint_links+=("E")
          # fi
          # or something, like that, to send a special message to the entrypoint
          # that these two are equal, and needed just for proper decision making
          # like scenario 3

          # Add to the entrypoint list
          just_docker_entrypoint_links+=("${volume_docker}"
                                         "${MOUNT_PREFIX-/host_mnt}${volume_host}")
          # Rewrite this volume
          volume_host="${host_mount_point}"


          volume_docker="${MOUNT_PREFIX-/host_mnt}${host_mount_point}"
        fi
      fi

      IFS=:
      volumes+=("      - ${volume_host}:${volume_docker}${volume_flags}")
      IFS="${OLD_IFS}"
    done
    # remove duplicates https://unix.stackexchange.com/q/159695,
    # docker-compose doesn't like them
    IFS=$'\n'
    volumes=($(awk '!count[$0]++' <<< ${volumes+"${volumes[*]}"}))
    if [ "${volumes+set}" == "set" ]; then
      echo "    volumes:"
      echo ${volumes+"${volumes[*]}"}
    fi
    IFS="${OLD_IFS}"

    new_environment=1
    if [ "${just_docker_entrypoint_links+set}" == "set" ]; then
      IFS=:
      _env_echo "      - JUST_DOCKER_ENTRYPOINT_LINKS=${just_docker_entrypoint_links[*]}"
      IFS="${OLD_IFS}"
    fi
    for var in $(compgen -A export); do
      # For project variables ending in _DOCKER, handle these specially
      if [[ $var =~ ^${project_prefix}_.*_DOCKER$ ]]; then
        indirect=${var%_DOCKER}

        if declare -p ${indirect}&>/dev/null; then
          if [ "${JUST_DISABLE_ENVIRONMENT_SWAP-}" == "1" ]; then
            _env_echo "      - ${indirect}=${!indirect}"
          else
            _env_echo "      - ${indirect}_HOST=${!indirect}"
          fi
        fi
        if [ "${JUST_DISABLE_ENVIRONMENT_SWAP-}" == "1" ]; then
          _env_echo "      - ${var}=${!var}"
        else
          _env_echo "      - ${indirect}=${!var}"
          if [ "${EXPORT_DOCKER-0}" == "1" ]; then
            _env_echo "      - ${indirect}_DOCKER=${!var}"
          fi
        fi
      # For project variables ending in _HOST, pass them along as-is
      elif [[ $var =~ ^${project_prefix}_.*_HOST$ ]]; then
        _env_echo "      - ${var}=${!var}"
      fi
    done
  done
}

if [[ ${BASH_SOURCE[0]} == ${0} ]] || [[ $(basename ${BASH_SOURCE[0]}) == ${0} ]]; then
  set -eu
  generate_docker_compose_override ${@+"${@}"}
fi